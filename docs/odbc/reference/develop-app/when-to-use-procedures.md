---
title: プロシージャを使用する場合 |Microsoft Docs
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- SQL statements [ODBC], procedures
- procedures [ODBC], about procedures
ms.assetid: 7dc9e327-dd54-4b10-9f66-9ef5c074f122
author: MightyPen
ms.author: genemi
ms.openlocfilehash: 6f25b629372bbe089489cccdbfa0258dafef3dd0
ms.sourcegitcommit: b2464064c0566590e486a3aafae6d67ce2645cef
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/15/2019
ms.locfileid: "68078970"
---
# <a name="when-to-use-procedures"></a>プロシージャを使用する場合
プロシージャを使用する利点のいくつかをすべて、という事実に基づいてプロシージャを使用して移動して SQL ステートメント データ ソースへのアプリケーションから。 残りのアプリケーションでは、相互運用可能なプロシージャ呼び出しです。 これらの利点があります。  
  
-   **パフォーマンス**プロシージャは、SQL ステートメントを実行する最も簡単な方法では、通常、します。 ように実行を準備するには、ステートメントをコンパイルし、別の 2 つの手順で実行します。 準備の実行とは異なり、プロシージャが実行時にのみ実行されます。 異なる時間にコンパイルされます。  
  
-   **ビジネス ルール**A*ビジネス ルール*を企業はビジネス方法に関するルールです。 たとえば、新しい販売注文を追加する販売員のタイトルを持つユーザーのみが許可可能性があります。 手順でこれらのルールを配置することにより、アプリケーション コードを変更することがなく、アプリケーションから呼び出されたプロシージャの書き直しを垂直方向のアプリケーションをカスタマイズする個々 の企業ができます。 たとえば、受注アプリケーションは、プロシージャを呼び出す可能性があります**InsertOrder**はパラメーターの数が固定正確に把握**InsertOrder**実装が会社を変更できます。  
  
-   **Replaceability**アプリケーションを再コンパイルしなくてもプロシージャを置き換えることができるという事実は、プロシージャのビジネス ルールを配置することに密接に関連します。 会社が購入し、アプリケーションをインストールした後にビジネス ルールが変更された場合、会社は、その規則を含むプロシージャを変更できます。 アプリケーションの観点から何も変更されました。でも、特定のタスクを実行する特定のプロシージャを呼び出します。  
  
-   **DBMS に固有の SQL**プロシージャは DBMS 固有の SQL の弱点を悪用して、引き続き相互運用可能なアプリケーションの方法を提供します。 たとえば、SQL でフロー制御ステートメントをサポートしている DBMS での手順は、トラップして、フロー制御ステートメントをサポートしていない DBMS での手順ではエラーを返す可能性がありますだけ中に、エラーから回復します。  
  
-   **プロシージャには、トランザクションが後も存続**トランザクションがコミットまたはロールバック時に一部のデータ ソースの接続ですべて準備されたステートメント用アクセス プランが削除されました。 データ ソースの永続的に格納されているトピックの手順で SQL ステートメントを配置することで、ステートメントは、トランザクションも存続します。 準備された、部分的に準備された場合、手順が存続するかどうか未完の状態は DBMS 固有です。  
  
-   **開発を区切る**プロシージャは、アプリケーションの残りの部分から個別に開発できます。 大規模な企業では、これによりさらに非常に特殊なプログラマのスキルを活用する方法が提供する可能性があります。 つまり、アプリケーション プログラマがユーザー インターフェイスのコードを記述し、データベース プログラマには、プロシージャを作成します。  
  
 プロシージャは、垂直方向およびカスタム アプリケーションで一般的に使用されます。 これらのアプリケーションは、固定のタスクを実行する傾向があるし、にハードコードされたプロシージャ呼び出しすることができます。 たとえば、受注アプリケーションは、プロシージャを呼び出すことができます**InsertOrder**、 **DeleteOrder**、 **UpdateOrder**、および**GetOrders**.  
  
 汎用アプリケーションからプロシージャを呼び出す理由はほとんどがありません。 特定のアプリケーションのコンテキストでタスクを実行する手順が記載されています、通常は、汎用的なアプリケーションを使用してがためありません。 たとえば、スプレッドシートにを呼び出す理由はありません、 **InsertOrder**先ほど説明した手順。 さらに、汎用アプリケーションする必要がありますいないプロシージャを作成しようと、ステートメントの実行速度が速く; を提供する実行時にだけでなく、準備された、直接実行するより低速な可能性がありますが、DBMS に固有の SQL ステートメントも必要です。  
  
 この例外は、多くの場合、プログラマがプロシージャを実行して、プロシージャをテストするプログラマのための方法を提供する SQL ステートメントを作成するための手段を提供するアプリケーションの開発環境です。 このような環境呼び出し**SQLProcedures**使用可能な手順の一覧と**SQLProcedureColumns**プロシージャ戻り値、および列の入力、入力/出力、および出力パラメーターを一覧表示するにはプロシージャによって作成された任意の結果セット。 ただし、このようなプロシージャ開発する必要が事前に各データ ソースため、これには、DBMS に固有の SQL ステートメントが必要です。  
  
 プロシージャを使用する 3 つの大きな欠点があります。 最初は、プロシージャを記述し、アプリケーションが実行するが、各 DBMS 用にコンパイルする必要があることです。 これは、カスタム アプリケーションの問題ではありません、開発と垂直方向のアプリケーションがさまざまな Dbms を実行するように設計のメンテナンス時間を大幅にお増やせます。  
  
 2 つ目の欠点は、多くの Dbms は、プロシージャをサポートされていないことです。 ここでも、垂直方向のアプリケーションがさまざまな Dbms を実行するように設計の問題が発生することが考えられます。 アプリケーションを呼び出すプロシージャはサポートされているかどうかを判断する**SQLGetInfo** SQL_PROCEDURES オプションを使用します。  
  
 アプリケーション開発環境に特に適用される 3 つ目の欠点は、ODBC にプロシージャを作成するための標準の文法が定義されていません。 つまり、アプリケーションでは、いつもプロシージャを呼び出すことができます、これらは作成できませんいつも。
