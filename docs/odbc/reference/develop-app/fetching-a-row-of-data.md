---
title: データの行をフェッチしています |Microsoft Docs
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- SQLFetch function [ODBC], fetching a row of data
- cursors [ODBC], fetching rows
- result sets [ODBC], fetching
- fetches [ODBC], row of data
ms.assetid: 16d4a380-0d83-456b-aeee-f10738944e86
author: MightyPen
ms.author: genemi
ms.openlocfilehash: 010d05990396c10836c0a2130e5d9f4392ae56ec
ms.sourcegitcommit: b2464064c0566590e486a3aafae6d67ce2645cef
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/15/2019
ms.locfileid: "68069857"
---
# <a name="fetching-a-row-of-data"></a>データの行のフェッチ
アプリケーションを呼び出す 1 行のデータをフェッチする**SQLFetch**します。 **SQLFetch**任意の種類のカーソルで呼び出すことができますが、順方向専用の方向にのみ行セットのカーソルを移動します。 **SQLFetch**次の行にカーソルを進めるし、データへの呼び出しにバインドされていたすべての列を返します**SQLBindCol**します。 設定すると、カーソルが結果の末尾に達したとき、 **SQLFetch** sql_no_data が返されます。 例については、呼び出し元の**SQLFetch**を参照してください[を使用して SQLBindCol](../../../odbc/reference/develop-app/using-sqlbindcol.md)します。  
  
 正確に把握**SQLFetch**実装は、ドライバーに固有では、一般的なパターンは、データ ソースから列をバインド、バインド先の変数の型に応じた変換および配置をいずれかのデータを取得するドライバー、これらの変数に変換後のデータ。 ドライバーは、すべてのデータを変換できない場合**SQLFetch**はエラーを返します。 アプリケーションは、行のフェッチを続行できますが、現在の行のデータは失われます。 バインドされていない列のデータを操作結果、ドライバーによって異なりますが、ほとんどのドライバーを取得および破棄またはまったく取得しません。  
  
 ドライバーでは、バインドされている任意の長さ/インジケーター バッファーの値も設定します。 列のデータ値が NULL の場合、ドライバーは SQL_NULL_DATA に対応する長さ/インジケーター バッファーを設定します。 データ値が NULL でない場合、ドライバーは、変換後のデータのバイト長に長さ/インジケーター バッファーを設定します。 この長さを特定できないように 1 つ以上の関数呼び出しによって取得される長い形式のデータの場合、ドライバーは SQL_NO_TOTAL を長さ/インジケーター バッファーを設定します。 整数や日付構造体などの固定長データ型のバイトの長さは、データ型のサイズです。  
  
 ドライバーを文字やバイナリ データなどの可変長データには、変換後のデータに対して、列にバインドされるバッファーのバイト長のバイトの長さを確認しますバッファーの長さがで指定された、 *BufferLength*引数**SQLBindCol**します。 変換後のデータのバイト長が、バッファーのバイトの長さよりも大きい場合は、ドライバーが、バッファーに収まるようにデータが切り捨てられます、切り詰められていない長さ/インジケーター バッファーの長さは、SQL_SUCCESS_WITH_INFO が返されます、SQLSTATE 01004 (データの配置を返します診断では切り捨て)。 唯一の例外は、によって返されるときに、可変長のブックマークが切り捨てられるかどうか**SQLFetch**、SQLSTATE 22001 (文字列データの右側が切り捨てられました) が返されます。  
  
 固定長のデータが切り捨てられなければ、ドライバーはバインドされているバッファーのサイズがデータ型のサイズであるためです。 データの切り捨ては、アプリケーションは通常、全体のデータ値を保持するために十分な大きさのバッファーをバインドするためには、まれで、傾向があります。メタデータから必要なサイズを決定します。 ただし、アプリケーションは、バッファーが小さすぎる認識を明示的にバインドする場合があります。 たとえば、取得し、表示部分の説明の最初の 20 文字または長いテキスト列の最初の 100 文字があります。  
  
 文字データがありますドライバーが null で終わる、アプリケーションに返される前に場合でもが切り捨てられました。 Null 終了文字は返されるバイトの長さには含まれませんが、バインドされたバッファー領域は必要があります。 たとえば、アプリケーションは、ASCII 文字セット内の文字データで構成される文字列を使用して、ドライバーが 50 文字の戻るには、データおよびアプリケーションのバッファーが 25 バイト長。 アプリケーションのバッファーには、ドライバーは、null 終端文字が続く最初の 24 文字を返します。 長さ/インジケーター バッファー、50 バイトの長さを返します。  
  
 アプリケーションでは、設定、結果を作成するステートメントを実行する前に、SQL_ATTR_MAX_ROWS ステートメント属性を設定して、結果セット内の行の数を制限できます。 たとえば、レポートを書式設定に使用するアプリケーションでプレビュー モードでは、レポートの最初のページを表示するための十分なデータのみが必要です。 結果セットのサイズを制限することでは、このような機能は高速に実行されます。 このステートメント属性は、ネットワーク トラフィックを削減するためのものがあり、すべてのドライバーでサポートされていない可能性があります。
