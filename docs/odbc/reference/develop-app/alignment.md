---
title: 配置 |Microsoft Docs
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- alignment issues [ODBC]
ms.assetid: 06a01e51-e7a5-495f-aa27-e304b0d005ff
author: MightyPen
ms.author: genemi
ms.openlocfilehash: b8b5a107f5ed8cd1c6c45317e60cc515a2601316
ms.sourcegitcommit: b2464064c0566590e486a3aafae6d67ce2645cef
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/15/2019
ms.locfileid: "68077272"
---
# <a name="alignment"></a>Alignment
ODBC アプリケーションでのアライメントの問題は通常ありません、他のアプリケーションよりも。 つまり、ほとんどの ODBC アプリケーションでは、配置にほとんどまたはまったくの問題があります。 しないアドレスの配置のペナルティはハードウェアおよびオペレーティング システムによって異なります、わずかなパフォーマンスの低下としてそのマイナーまたは実行時の致命的なエラーとしてとしてメジャーがあります。 そのため、ODBC アプリケーション、および ODBC アプリケーションの移植可能な具体的には、注意が必要にデータを正しく配置します。  
  
 1 つの ODBC アプリケーションが配置の問題が発生する場合の例はそのメモリのさまざまな部分を結果セット内の列にバインドし、大きなメモリ ブロックを割り当てます。 実行時に結果セットの形状を決定しを割り当て、それに応じてメモリをバインドする必要があります汎用アプリケーションときに発生することが考えられます。  
  
 たとえば、アプリケーションを実行、**選択**ステートメントは、ユーザーが入力し、このステートメントから結果をフェッチします。 不明なためこの結果セットの形状、プログラムを記述するときに、アプリケーションは、結果セットを作成した後、各列の型を特定し、それに応じてメモリをバインドする必要があります。 これを行う最も簡単な方法では、大きなメモリ ブロックを割り当てるし、そのブロック内の別のアドレスを各列にバインドします。 列のデータにアクセスするには、アプリケーションは、その列にバインドされているメモリをキャストします。  
  
 次の図は、設定し、各 SQL データ型の既定の C データ型を使用してメモリ ブロックをバインドする方法、サンプルの結果を示します。 各"X"は、1 バイトのメモリを表します。 (この例では、列にバインドされているデータ バッファーのみを示しています。 これはわかりやすくするためです。 実際のコードで長さ/インジケーター バッファーする必要がありますで配置されます。)  
  
 ![SQL データ型に既定の C データ型によってバインド](../../../odbc/reference/develop-app/media/pr24.gif "pr24")  
  
 格納されているが、バインド アドレスと仮定すると、*アドレス*配列、アプリケーションを使用して、次の式の各列にバインドされているメモリにアクセスします。  
  
```  
(SQLCHAR *)       Address[0]  
(SQLSMALLINT *)   Address[1]  
(SQLINTEGER *)    Address[2]  
```  
  
 2 番目のアドレスがバインドされていることと 3 番目の列が奇数バイトの開始され、4、SDWORD のサイズがで割り切れるはアドレスは、3 番目の列にバインドされていることを確認します。 一部のコンピューターでこの操作が問題です。他のユーザーにわずかなパフォーマンス ペナルティ; が発生します。まだ他の致命的な実行時エラーが発生します。 自然なアラインメント境界にバインドされている各アドレスを配置することをお勧めします。 1 UCHAR、SWORD、2 および 4 は、SDWORD、これがこのように結果"X"が使用されるメモリのバイトを表し、"O"が使用されていないメモリのバイトを表す、次の図に示すようにします。  
  
 ![自然な配置境界によるバインド](../../../odbc/reference/develop-app/media/pr25.gif "pr25")  
  
 このソリューションでは、すべてのアプリケーションのメモリ使用していない、ときに、配置の問題がなければします。 残念ながら、その型に応じて各列を個別に配置する必要があります、かなりの量をこのソリューションを実装するコードがかかります。 サイズの最大の配置の境界は 4 は、すべての列を整列する簡単なソリューションは、次の図に示した例では。  
  
 ![最大の配置境界によるバインド](../../../odbc/reference/develop-app/media/pr26.gif "pr26")  
  
 このソリューションでは、大きなセキュリティ ホールが退職、それを実装するコードは比較的簡単で高速です。 ほとんどの場合は、未使用のメモリ内で、パフォーマンス低下が相殺されます。 このメソッドを使用して、例では、次を参照してください。[を使用して SQLBindCol](../../../odbc/reference/develop-app/using-sqlbindcol.md)します。
