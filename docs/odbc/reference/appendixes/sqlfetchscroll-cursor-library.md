---
title: SQLFetchScroll (カーソル ライブラリ) |Microsoft Docs
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- SQLFetchScroll function [ODBC], Cursor Library
ms.assetid: 4417e57c-31dd-475e-8fe9-eab00a459c80
author: MightyPen
ms.author: genemi
ms.openlocfilehash: 16e7e4d133fdfafd7a005c19b0a2943b2ea9ef6d
ms.sourcegitcommit: b2464064c0566590e486a3aafae6d67ce2645cef
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/15/2019
ms.locfileid: "68086454"
---
# <a name="sqlfetchscroll-cursor-library"></a>SQLFetchScroll (カーソル ライブラリ)
> [!IMPORTANT]  
>  この機能は、Windows の将来のバージョンで削除されます。 新しい開発作業でこの機能を使用しないようにして、現在この機能を使用しているアプリケーションの変更を検討してください。 ドライバーのカーソル機能を使用することをお勧めします。  
  
 このトピックの使用、 **SQLFetchScroll**カーソル ライブラリ内の関数。 に関する一般的な情報**SQLFetchScroll**を参照してください[SQLFetchScroll 関数](../../../odbc/reference/syntax/sqlfetchscroll-function.md)します。  
  
 カーソル ライブラリを実装して**SQLFetchScroll**を繰り返し呼び出す**SQLFetch**ドライバー。 ドライバーから、アプリケーションによって提供される行セットのバッファーを取得するデータを転送します。 また、メモリとディスクのファイル内のデータをキャッシュします。 アプリケーションが新しい行セットを要求すると、カーソル ライブラリを取得しますが (それ以前まだフェッチされていない) 場合、ドライバーまたはキャッシュから、必要に応じて (既にフェッチされている以前) の場合。 最後に、カーソル ライブラリでは、キャッシュされたデータの状態を保持し、行の状態配列内のアプリケーションにこの情報を返します。  
  
 カーソル ライブラリを使用すると、呼び出し**SQLFetchScroll**いずれかへの呼び出しを混在させることはできません**SQLFetch**または**SQLExtendedFetch**します。  
  
 カーソル ライブラリを使用すると、呼び出し**SQLFetchScroll**は ODBC 2 の両方がサポートされています *。x* 、ODBC 3 *。x*ドライバー。  
  
## <a name="rowset-buffers"></a>バッファーの行セット  
 カーソル ライブラリでは、ドライバーの場合に、アプリケーションによって提供される行セット バッファーへのデータ転送を最適化します。  
  
-   アプリケーションでは、行方向のバインドを使用します。  
  
-   データの行を保持するために、アプリケーションを宣言する構造体のフィールド間では、未使用のバイトはありません。  
  
-   これでフィールド**SQLFetch**または**SQLFetchScroll**列でその列のバッファーに依存して、[次へ] の列に対してバッファーの長さまたはインジケーターを返します。 これらのフィールドは省略可能です。  
  
 アプリケーションが新しい行セットを要求すると、カーソル ライブラリは、必要に応じて、ドライバーとそのキャッシュからデータを取得します。 新規および既存の行セットが重なっている場合、カーソル ライブラリは、重複する部分を行セットのバッファーからデータを再利用してそのパフォーマンスを最適化できます。 そのため、新規および既存の行セットの重複され、変更が重複する行セットのバッファーのセクションではない限りは、行セットのバッファーに保存されていない変更は失われます。 変更を保存するには、アプリケーションは、位置指定の update ステートメントを送信します。  
  
 アプリケーションを呼び出すと、カーソル ライブラリがそのキャッシュからのデータを行セットのバッファーを常に更新されるに注意してください**SQLFetchScroll**で、 *FetchOrientation*引数 SQL_FETCH_RELATIVE に設定し、*FetchOffset*引数は 0 に設定します。  
  
 カーソル ライブラリ呼び出しをサポートする**SQLSetStmtAttr**で、*属性*カーソルが開いている間、行セットのサイズを変更する sql_attr_row_array_size を指定します。 新しい行セットのサイズは、次回に効果にかかる**SQLFetchScroll**が呼び出されます。  
  
## <a name="result-set-membership"></a>結果セットのメンバーシップ  
 カーソル ライブラリは、アプリケーションを要求するときにのみ、ドライバーからデータを取得します。 このデータ ソース、SQL_CONCURRENCY ステートメント属性の設定に応じて、次のような影響があります。  
  
-   カーソル ライブラリによって取得されたデータは、ステートメントの実行時に利用可能だったデータを異なる場合があります。 など、カーソルが開かれた後に現在のカーソル位置より後ろの位置に挿入された行は一部のドライバーによって取得できます。  
  
-   結果セット内のデータは、カーソル ライブラリのデータ ソースによってロックされている可能性があります、ために他のユーザーに利用できません。  
  
 カーソル ライブラリが 1 行のデータをキャッシュされた後 (位置指定更新と削除は、同じカーソルのキャッシュで動作している) を除く、基になるデータ ソースでその行に対する変更を検出できません。 これは、ためへの呼び出しに**SQLFetchScroll**、カーソル ライブラリは、データ ソースからデータを決して変わりません。 代わりに、そのキャッシュからデータを変わりません。  
  
## <a name="scrolling"></a>スクロール  
 カーソル ライブラリで次のフェッチの型をサポートしている**SQLFetchScroll**します。  
  
|カーソルの種類|フェッチの種類|  
|-----------------|-----------------|  
|順方向専用|SQL_FETCH_NEXT|  
|スタティック|SQL_FETCH_NEXT<br /><br /> SQL_FETCH_PRIOR<br /><br /> SQL_FETCH_FIRST<br /><br /> SQL_FETCH_LAST<br /><br /> SQL_FETCH_RELATIVE<br /><br /> SQL_FETCH_ABSOLUTE<br /><br /> SQL_FETCH_BOOKMARK|  
  
## <a name="errors"></a>エラー  
 ときに**SQLFetchScroll**呼びますへの呼び出しの 1 つ**SQLFetch** SQL_ERROR、ライブラリのカーソル処理の進行状況を次のように返します。 次の手順が完了すると、カーソル ライブラリによって処理が続行されます。  
  
1.  呼び出し**SQLGetDiagRec**ドライバーからエラー情報を取得し、これをドライバー マネージャーでの診断レコードとして投稿します。  
  
2.  適切な値の診断レコードで SQL_DIAG_ROW_NUMBER フィールドを設定します。  
  
3.  該当する場合は、適切な値では、診断レコードで SQL_DIAG_COLUMN_NUMBER フィールドを設定しますそれ以外の場合、これを 0 に設定します。  
  
4.  SQL_ROW_ERROR、行の状態配列内のエラー行の値を設定します。  
  
 カーソルより後にライブラリが呼び出されて**SQLFetch**の実装内で複数回**SQLFetchScroll**、エラーまたは警告のいずれかへの呼び出しによって返される**SQLFetch**診断レコードになりへの呼び出しで取得できる**SQLGetDiagRec**します。 フェッチされたときに、データが切り捨てられる場合、切り捨てられたデータは、カーソル ライブラリのキャッシュに存在ようになりました。 後続の呼び出し**SQLFetchScroll**を持つ行にスクロールする切り捨てられたデータが切り捨てられたデータを返すし、カーソル ライブラリのキャッシュからデータがフェッチされるため、警告は発生しません。 バッファーに返されるデータが切り捨てられましたかどうかを判断できるように返されるデータの長さを追跡するのには、アプリケーションが長さ/インジケーター バッファーをバインドする必要があります。  
  
## <a name="bookmark-operations"></a>ブックマークの操作  
 カーソル ライブラリ呼び出しをサポートする**SQLFetchScroll**で、 *FetchOrientation* SQL_FETCH_BOOKMARK の。 オフセットを指定することもサポート、 *FetchOffset*ブックマーク操作で使用できる引数。 これは、唯一のブックマーク操作で、カーソル ライブラリをサポートしています。 カーソル ライブラリは、呼び出し元をサポートしていません**SQLBulkOperations**します。  
  
 アプリケーションが SQL_ATTR_USE_BOOKMARKS ステートメントの属性が設定、ブックマーク列にバインドされている場合、カーソル ライブラリは固定長のブックマークを生成し、し、アプリケーションに返します。 カーソル ライブラリを作成および; を使用して、それらのブックマークの管理データ ソースで管理されているブックマークは使用しません。 ときに**SQLFetchScroll**と呼びますが既にデータ ソースからフェッチされたデータのブロックを取得するカーソル ライブラリのキャッシュからデータを取得します。 ブックマークがへの呼び出しで使用されるため、 **SQLFetchScroll**で、 *FetchOrientation*の SQL_FETCH_BOOKMARK を作成し、カーソル ライブラリによって管理される必要があります。  
  
## <a name="interaction-with-other-functions"></a>その他の関数との対話  
 アプリケーションを呼び出す必要があります**SQLFetch**または**SQLFetchScroll**更新配置されているいずれか、または delete ステートメントが準備または実行する前にします。
