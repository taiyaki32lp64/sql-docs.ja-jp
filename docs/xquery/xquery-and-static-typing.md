---
title: XQuery と静的入力 |Microsoft Docs
ms.custom: ''
ms.date: 03/17/2017
ms.prod: sql
ms.prod_service: sql
ms.reviewer: ''
ms.technology: xml
ms.topic: language-reference
dev_langs:
- XML
helpviewer_keywords:
- XQuery, static typing
- static typing
- checking static types
- inference [XQuery]
ms.assetid: d599c791-200d-46f8-b758-97e761a1a5c0
author: rothja
ms.author: jroth
ms.openlocfilehash: 5ad42a174f558202544650fb1580574f290d4466
ms.sourcegitcommit: b2464064c0566590e486a3aafae6d67ce2645cef
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/15/2019
ms.locfileid: "67946083"
---
# <a name="xquery-and-static-typing"></a>XQuery と静的な型指定
[!INCLUDE[tsql-appliesto-ss2012-xxxx-xxxx-xxx-md](../includes/tsql-appliesto-ss2012-xxxx-xxxx-xxx-md.md)]

  [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] の XQuery は静的型指定の言語です。 つまり、クエリのコンパイル中に型エラーを生成、式を型または特定の関数または演算子では許容されませんカーディナリティを持つ値を返すときにします。 さらに、静的な型チェックも検出できますパス式で型指定された XML ドキュメントの誤りがあるかどうか。 XQuery コンパイラは、アトミック化などの暗黙的な操作を加える正規化を適用してから、静的な型の推定および確認を行います。  
  
## <a name="static-type-inference"></a>静的な型の推定  
 静的な型の推定では、式の戻り型が判定されます。 この判定は、入力パラメーターの静的な型および演算の静的なセマンティクスを取得し、結果の静的な型を推定することで行われます。 たとえば、式 1 + 2.3 の静的な型は、次のように決定されます。  
  
-   1 の静的な型は**xs:integer** 2.3 の静的な型であり**xs:decimal**します。 動的のセマンティクスの静的なセマンティクスに基づく、 **+** 操作、整数を 10 進数に変換し、10 進数を返します。 推論された静的な型になりますし**xs:decimal**します。  
  
 XML インスタンスの型指定されていない場合は、データが入力しないことを示すの特別な種類があります。 その情報は、静的な型チェックのときに暗黙的に型をキャストするために使用されます。  
  
 型指定されたデータの場合、XML データ型インスタンスを制約する XML スキーマ コレクションから入力の型が推定されます。 たとえば、スキーマ型の要素のみを許可する**xs:integer**、型の 0 個以上の要素、その要素を使用して、パス式の結果になる**xs:integer**します。 などの式を使用して、この表現は、現在`element(age,xs:integer)*`、アスタリスク (\*)、結果の型のカーディナリティを示します。 名前"age"と型の 0 個以上の要素で、この例では式の結果が**xs:integer**します。 他の基数は正確に 1 つと単独で、型名を使用して表されます 0 個または 1 と疑問符 () を使用して表されます (**でしょうか**)、および 1 または詳細、プラス記号を使用して表されます ( **+** ).  
  
 場合によっては、静的な型推論では、式の空のシーケンスが常に返すことを推測できます。 たとえば、パス式で型指定された XML データ型の検索、\<名 > 内の要素を\<顧客 > (顧客/名前)、要素は、スキーマが許可しない、\<名 > 内で、\<顧客 >、静的な型の推論は、結果を空にすることを推論します。 これは不適切なクエリを検出するために使用して、式が () しない限り、静的なエラーとして報告されますまたは**データ (())** します。  
  
 推定規則の詳細は、XQuery 仕様の正式なセマンティクスで提供されます。 マイクロソフトでは、型指定された XML データ型のインスタンスに対応するためにこの規則を少しだけ変更しました。 標準からの最も重要な変更点は、暗黙的なドキュメント ノードで XML データ型のインスタンスの型を認識することです。 その結果、フォーム/age のパス式は正確に入力するその情報に基づいて。  
  
 使用して[SQL Server Profiler のテンプレートと権限](../tools/sql-server-profiler/sql-server-profiler-templates-and-permissions.md)クエリのコンパイルの一部として返される静的な型を確認できます。 これらを確認するには、トレースに TSQL イベント カテゴリの XQuery Static Type イベントが含まれている必要があります。  
  
## <a name="static-type-checking"></a>静的な型チェック  
 静的な型チェックにより、実行時の実行でが適切な操作の種類の値のみを受信します。 実行時には必ずしも型がチェックされるとは限りませんが、コンパイルの初期段階で潜在的なエラーを検出できます。 これにより、パフォーマンスが向上します。 ただし、静的な型指定を使用する場合、クエリの記述には通常以上の配慮が必要になります。  
  
 次に、使用できる適切な型を示します。  
  
-   関数または演算で明示的に許可されている型。  
  
-   明示的に許可されている型のサブタイプ。  
  
 サブタイプは、XML スキーマの制約または拡張による派生を使用するためのサブタイプ指定規則に基づいて定義されます。 たとえば、型が S であるすべての値が型 T のインスタンスでもある場合、型 S は型 T のサブタイプです。  
  
 さらに、すべての整数値は、XML スキーマ型の階層に基づく、10 進数の値ではまたです。 一方、decimal 型のすべての値が integer 型の値であるとは限りません。 サブタイプは、整数はそのため、10 進数が、その逆はありません。 たとえば、 **+** 操作では、数値型など、特定の種類の値のみが許可**xs:integer**、 **xs:decimal**、 **xs:float**、および**xs:double**します。 などの他の値型する場合**xs:string**が渡されると、操作は、型エラーが発生します。 これは厳密な型指定と呼ばれます。 型指定されていない XML を示すために使用するアトミック型など、他の型の値は、操作が受け取る型の値に暗黙的に変換できます。 これを弱い型指定と呼びます。  
  
 暗黙的な変換の後での静的な型チェックを必須にした場合、カーディナリティが正しく、許可された型の値のみが演算に渡されます。 "String"+ 1 の場合は"string"の静的な型は、ことを認識**xs:string**します。 許容される型でないため、 **+** 操作、型エラーが発生します。  
  
 任意の式 E1 の結果に任意の式 E2 を加算する (E1 + E2) 場合、静的な型の推定によって E1 および E2 の静的な型が判定されたうえで、それらの型が演算に許可されている型であるかどうかのチェックが行われます。 たとえば、E1 の静的な型には、いずれかを指定できる場合は、 **xs:string**または**xs:integer**実行時が整数である場合でも、いくつかの値で、静的な型チェック、型のエラーを発生させます。 大文字と小文字 E1 の静的な型の場合も同様**xs:integer&#42;** します。 **+** 操作は 1 つの整数値のみを受け入れる、E1 は 0 を返すことができ、または、1 つ以上の静的な型チェック エラーが発生します。  
  
 前述のように、型の推論は頻繁に渡されるデータの種類について知っているユーザーよりも広範なである型を推論します。 そのような場合は、ユーザーがクエリを書き換える必要があります。 一般的なケースを次のとおりです。  
  
-   スーパータイプまたは型の共用体など、汎化された型が推定される。 種類がアトミック型の場合を実際の静的な型を示すために、cast 式またはコンス トラクター関数を使用する必要があります。 たとえば、式 E1 の推論された型の間での選択肢は、 **xs:string**または**xs:integer**を追加する必要があります**xs:integer**を記述する必要があります`xs:integer(E1) + E2`の代わりに`E1+E2`します。 文字列値が検出された場合、実行時にこの式が失敗するキャストできません**xs:integer**します。 ただし、この式は静的な型チェックには合格します。 この式は空のシーケンスにマップされます。  
  
-   データの実際の内容を上回るカーディナリティが推定される。 これは、多くの場合、 **xml**データ型は、1 つ以上の最上位要素を含めることができ、XML スキーマ コレクションで制約することはできません。 静的な型を限定し、渡される値の数を 1 以下にするためには、位置関係の述語 `[1]` を使用してください。 たとえば、属性の値に 1 を加算する`c`要素の`b`、最上位要素 a、する必要があります`write (/a/b/@c)[1]+1`します。 さらに、XML スキーマ コレクションと共に DOCUMENT キーワードを使用できます。  
  
-   一部の操作には、推定時に型情報が失われます。 たとえば、ノードの種類を決定できない場合になった**anyType**します。 これは、その他の種類には暗黙的にキャストできません。 これらの変換は、parent 軸を使用して、ナビゲーション中に最も顕著な発生します。 式で静的な型のエラーが発生する場合、そのような演算の使用は避け、クエリを書き換えてください。  
  
## <a name="type-checking-of-union-types"></a>共用体の型の型チェック  
 共用体の型では、型チェックのため注意して処理が必要です。 問題の 2 つは、次の例に示します。  
  
### <a name="example-function-over-union-type"></a>例:Union 型に関数  
 要素の定義を検討してください <`r`> 共用体型の。  
  
```  
<xs:element name="r">  
<xs:simpleType>  
   <xs:union memberTypes="xs:int xs:float xs:double"/>  
</xs:simpleType>  
</xs:element>  
```  
  
 "Average"、関数、XQuery のコンテキスト内で`fn:avg (//r)`XQuery コンパイラは、さまざまな種類の値を追加できないため、静的なエラーを返します (**xs:int 型**、 **xs:float**または**xs:二重**) の <`r`> 要素の引数で**fn:avg()** します。 これを解決するには、関数の呼び出し部分を「`fn:avg(for $r in //r return $r cast as xs:double ?)`」と書き換えます。  
  
### <a name="example-operator-over-union-type"></a>例:Union 型に演算子  
 加算演算 ('+') では、オペランドの正確な型が必要です。 したがって、式として`(//r)[1] + 1`を要素の前に説明した種類の定義を持つ静的なエラーを返します <`r`>。 解決策の 1 つは、「`(//r)[1] cast as xs:int? +1`」("?" は 0 回または 1 回の出現を示す) に書き換える方法です。 [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] では、すべてのキャストは実行時エラーの結果として空のシーケンスになる可能性があるので、"cast as" に "?" を付ける必要があります。  
  
## <a name="see-also"></a>関連項目  
 [XQuery 言語リファレンス &#40;SQL Server&#41;](../xquery/xquery-language-reference-sql-server.md)  
  
  
