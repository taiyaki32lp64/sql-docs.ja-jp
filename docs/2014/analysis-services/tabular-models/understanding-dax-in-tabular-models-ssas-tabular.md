---
title: 表形式モデル (SSAS テーブル) での DAX を理解する |Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: analysis-services
ms.topic: conceptual
ms.assetid: b2693985-1bea-4861-a100-cea4761ba809
author: minewiskan
ms.author: owend
manager: craigg
ms.openlocfilehash: a218855202eec9109718d5090acf16e80da42b6a
ms.sourcegitcommit: 0818f6cc435519699866db07c49133488af323f4
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/20/2019
ms.locfileid: "67284920"
---
# <a name="understanding-dax-in-tabular-models-ssas-tabular"></a>テーブル モデルでの DAX について (SSAS テーブル)
  Data Analysis Expressions (DAX) は、 [!INCLUDE[ssGemini](../../includes/ssgemini-md.md)] for Microsoft Excel のブックおよび [!INCLUDE[ssASnoversion](../../includes/ssasnoversion-md.md)] のテーブル モデル プロジェクトでカスタムの計算を作成するための数式言語です。 DAX の数式は、テーブル内や列内のデータに対して高度な計算を実行するための関数、演算子、値などで構成されます。  
  
 DAX は、 [!INCLUDE[ssGemini](../../includes/ssgemini-md.md)] ブックとテーブル モデル プロジェクトのどちらでも利用できますが、このトピックでは、 [!INCLUDE[ssBIDevStudioFull](../../includes/ssbidevstudiofull-md.md)]で作成したテーブル モデル プロジェクトでの利用を想定して取り上げます。 このトピックを読むには、テーブル モデルについて十分に理解している必要があります。 [!INCLUDE[ssBIDevStudioFull](../../includes/ssbidevstudiofull-md.md)]におけるテーブル モデル プロジェクト作成環境についても、よく理解しておく必要があります。  
  
 このトピックのセクション:  
  
-   [テーブル モデルにおける DAX](#bkmk_DAXintm)  
  
-   [計算列、メジャー、および行フィルターにおける DAX の数式](#bkmk_DAX)  
  
-   [DAX データ型](#bkmk_DAX_datatypes)  
  
-   [DAX の演算子](#bkmk_DAX_opertors)  
  
-   [DAX の数式](#bkmk_DAX_Formulas)  
  
-   [DAX 関数](#bkmk_DAX_functions)  
  
-   [DAX の数式のコンテキスト](#bkmk_context)  
  
-   [数式とテーブル モデル](#bkmk_RelModel)  
  
-   [テーブルと列の操作](#bkmk_tables)  
  
-   [数式の結果の更新 (処理)](#bkmk_RefreshRecalc)  
  
-   [数式内のエラーのトラブルシューティング](#bkmk_troubleshoot)  
  
-   [その他のリソース](#bkmk_addional_resources)  
  
##  <a name="bkmk_DAXintm"></a> テーブル モデルにおける DAX  
 [!INCLUDE[ssGemini](../../includes/ssgemini-md.md)] とテーブル モデルのどちらでも、それぞれのデータセットから DAX の数式によって値が計算されるしくみに、機能上の違いはありません。 ただし、ブックおよびモデル作成ツールにおいて DAX の数式がどこで作成されるのか、また、特定のメジャーのコンテキストがどこで評価されるのかという点は異なります。  
  
 [!INCLUDE[ssGemini](../../includes/ssgemini-md.md)]では、セルフサービス ビジネス インテリジェンス分析を目的としてブックのユーザーが計算式を作成するのが一般的です。 PowerPivot ウィンドウでテーブルに対する計算列が作成され、ピボットテーブルまたは計算領域でメジャーが作成されます。 テーブル モデル プロジェクトとは異なり、PowerPivot ブックには、データをセキュリティ保護するために DAX 式を使用できる、ロールベースのセキュリティ機能が備わっていません。  
  
 テーブル モデル プロジェクトでは、計算式は、モデルの作成者が [!INCLUDE[ssBIDevStudioFull](../../includes/ssbidevstudiofull-md.md)] のモデル デザイナーで作成します。 メジャー グリッドのメジャー プレビュー機能を除き、DAX の数式を使用して計算された計算列の値は、モデル デザイナーのテーブルにすぐに表示されますが、メジャーはユーザーが [!INCLUDE[ssCrescent](../../includes/sscrescent-md.md)] や Microsoft Excel 内のピボットテーブルなどのレポート クライアントでフィルターを指定するまで計算されません。  
  
 新しいテーブル モデル プロジェクトに対し、"PowerPivot からのインポート" プロジェクト テンプレートを使用して PowerPivot ブックをインポートした場合、新しいテーブル モデルには、計算列に対する DAX の数式が自動的に作成されます。 そのブック内の暗黙的なメジャーと明示的なメジャーに対する DAX の数式は、新しいテーブル モデルには明示的なメジャーとして自動的に作成されます。 PowerPivot ブックにはロールおよびセキュリティ保護行フィルターの機能が最初から存在するわけではありません。そのため、モデル データにロールのメンバーがアクセスできるようにするには、新しいテーブル モデルに少なくとも 1 つのロールを作成する必要があります。 行フィルターにおいて DAX 式が必要となるのは、テーブル データのセキュリティを行レベルで確保する場合のみです。  
  
##  <a name="bkmk_DAX"></a> 計算列、メジャー、および行フィルターにおける DAX の数式  
 [!INCLUDE[ssBIDevStudioFull](../../includes/ssbidevstudiofull-md.md)]で作成されるテーブル モデルでは、計算列、メジャー、および行フィルターで DAX の数式が使用されます。  
  
### <a name="calculated-columns"></a>計算列  
 計算列は、(モデル デザイナーで) 既存のテーブルに追加する列であり、その列の値は、DAX の数式を作成することによって定義されます。 計算列に対する式は、モデル デザイナーから数式バーを使用して作成します。  
  
> [!NOTE]  
>  計算列は、DirectQuery モードを使用してリレーショナル データ ソースからデータを取得するモデルではサポートされません。  
  
 計算列に格納されているのが有効な DAX 数式であれば、その式を入力するとすぐ行ごとに値が計算されます。 そして、値はデータベースに格納されます。 たとえば、Date テーブルで、数式バーに「 `=[Calendar Year] & " Q" & [Calendar Quarter]` 」という数式を入力すると、テーブルの各行の値が計算されます。具体的には、(同じ Date テーブルの) Calendar Year 列の値にスペースと大文字の Q が付加され、さらに (同じ Date テーブルの) Calendar Quarter 列の値が付加されます。 計算列の各行の結果が直ちに計算されて、たとえば、" **2010 Q1**" と表示されます。 データが再処理された場合に限り、列の値が再計算されます。  
  
 詳細については、「[計算列 &#40;SSAS テーブル&#41;](ssas-calculated-columns.md)」を参照してください。  
  
### <a name="measures"></a>メジャー  
 メジャーは、コンテキストに応じて結果が変化する動的な数式です。 メジャーは、 [!INCLUDE[ssCrescent](../../includes/sscrescent-md.md)] レポートや Excel ピボットテーブル、ピボットグラフなど、複数の属性を使用するモデル データの組み合わせとフィルター処理をサポートするレポート形式で使用されます。 テーブル モデル プロジェクトでは、モデル作成者が、 [!INCLUDE[ssBIDevStudioFull](../../includes/ssbidevstudiofull-md.md)]からモデル デザイナーで、メジャー グリッド (および数式バー) を使用してメジャーを定義します。  
  
 メジャーの数式で、COUNT や SUM など、オート SUM 機能を使用して自動的に作成された標準の集計関数を使用することも、DAX を使用して独自の数式を定義することもできます。 数式バーでメジャーの数式を定義すると、現在のコンテキスト全体に対する結果のプレビューがツールヒント機能を使用して表示されます。ただし、それ以外の結果はすぐには表示されません。 メジャーに関するその他の詳しい情報は、 **[プロパティ]** ペインに表示されます。  
  
 (フィルターされた) 計算結果をすぐに確認できない理由は、コンテキストがない限りメジャーの結果が決定されないためです。 メジャーを評価するには、各セルに関連するデータを取得して、各セルの式を評価するために必要なコンテキストを提供できるレポート クライアント アプリケーションが必要です。 クライアントとしては、Excel ピボットテーブル (またはピボットグラフ)、 [!INCLUDE[ssCrescent](../../includes/sscrescent-md.md)] レポート、または MDX クエリを使用できます。 レポート クライアントにかかわらず、結果では各セルについて個別のクエリが実行されます。 つまり、ピボットテーブルでの行見出しと列見出しの組み合わせごとに、または [!INCLUDE[ssCrescent](../../includes/sscrescent-md.md)] レポートで選択されているスライサーとフィルターごとに、メジャーの計算を行うデータから異なるサブセットが生成されます。 たとえば、数式を含んだメジャー " `Total Sales:=SUM([Sales Amount])`" において、ユーザーが、ピボットテーブルの [値] ウィンドウで Total Sales メジャーを配置し、その後、Product テーブルの Product Category 列を [フィルター] ウィンドウに配置した場合、Sales Amount の合計が製品カテゴリごとに計算されて表示されます。  
  
 計算列や行フィルターとは異なり、メジャーの構文には、数式の前に、メジャーの名前が含まれています。 この例では、" **Total Sales:** " という名前が数式の前に付きます。 メジャーの作成が終了すると、名前と定義がレポート クライアント アプリケーションのフィールド リストに表示され、パースペクティブとロールに応じて、モデルのすべてのユーザーがメジャーを利用できるようになります。  
  
 詳細については、「[メジャー &#40;SSAS テーブル&#41;](measures-ssas-tabular.md)」を参照してください。  
  
### <a name="row-filters"></a>行フィルター  
 行フィルターは、テーブル内のどの行が特定のロールのメンバーに表示されるのかを指定します。 行フィルターは、DAX 式を使用してモデル内の各テーブルに対して作成できます。 行フィルターは、特定のロールに対し、 [!INCLUDE[ssManStudioFull](../../includes/ssmanstudiofull-md.md)]のロール マネージャーを使用して作成されます。 [!INCLUDE[ssManStudioFull](../../includes/ssmanstudiofull-md.md)]からロールのプロパティを使用し、配置済みのモデルに対して行フィルターを定義することもできます。  
  
 行フィルターでは、DAX の数式 (これはブール値の TRUE/FALSE 条件に評価される必要がある) により、その特定のロール メンバーがクエリ結果を返す行が定義されます。 DAX の数式に含まれていない行は返されません。 たとえば、Sales ロールのメンバーの場合、 `=Customers[Country] = "USA"`という DAX 式を持つ Customers テーブルでは、米国内の顧客データのみを表示でき、SUM などの集計は米国内の顧客だけを対象にした値を返します。  
  
 DAX の数式を使用して行フィルターを定義する場合、許可済みの行セットを作成していることになります。 これは、他の行へのアクセスを否定するのではなく、単に、許可済みの行セットの一部として、それらは返されないだけです。 他のロールは、DAX の数式によって除外された行へのアクセスを許可できます。 ユーザー別のロールのメンバーである、そのロールの行フィルターがその特定の行セットへのアクセスを許可する場合は、ユーザーは、その行のデータを表示できます。  
  
 行フィルターは、指定行と関連行に適用されます。 1 つのテーブルに複数のリレーションシップがある場合、フィルターによりセキュリティがアクティブなリレーションシップに適用されます。 行フィルターには、関連テーブルに対して定義された他の行フィルターと類似する点があります。  
  
 詳細については、「 [ロール &#40;SSAS テーブル&#41;](roles-ssas-tabular.md)で作成したテーブル モデル プロジェクトでの利用を想定して取り上げます。  
  
##  <a name="bkmk_DAX_datatypes"></a> DAX データ型  
 多様なデータ型をサポートするさまざまなデータ ソースから、モデルにデータをインポートできます。 モデルにデータをインポートする場合、そのデータはいずれかのテーブル モデル データ型に変換されます。 モデル データが計算に使用される場合、そのデータは計算中および計算の出力時に DAX データ型に変換されます。 DAX の数式を作成すると、数式に使用されている語句によって、返される値のデータ型が自動的に判断されます。  
  
 テーブル モデルと DAX の組み合わせでは、次のデータ型がサポートされます。  
  
|モデルでのデータ型|DAX のデータ型|説明|  
|------------------------|----------------------|-----------------|  
|整数|64 ビット (8 バイト) の整数値 <sup>1、2</sup>|小数点以下を含まない数値。 整数は正の数値または負の数値のどちらも有効ですが、-9,223,372,036,854,775,808 (-2^63) ～ 9,223,372,036,854,775,807 (2^63-1) の範囲の整数でなければなりません。|  
|10 進数|64 ビット (8 バイト) の実数 <sup>1、2</sup>|小数点以下を含む数値。 実数では次のような幅広い値が有効です。<br /><br /> 負の値 (-1.79E +308 ～ -2.23E -308 の範囲)<br /><br /> Zero<br /><br /> 正の値 (2.23E -308 ～ 1.79E + 308 の範囲)<br /><br /> ただし、有効桁数は小数点以下が 17 桁に制限されます。|  
|ブール値|ブール値|True または False の値。|  
|テキスト|String|Unicode 文字データ文字列。 文字列、数字、またはテキスト形式で表現される日付を使用できます。|  
|date|日付/時刻|許容された日付時刻表現による日付および時刻。<br /><br /> 1900 年 3 月 1 日より後のすべての日付が有効です。|  
|通貨|通貨|通貨データ型では、-922,337,203,685,477.5808 ～ 922,337,203,685,477.5807 の範囲の値 (小数点以下が 4 桁で有効桁数が固定長) が有効です。|  
|なし|空白|空白は、DAX では SQL の NULL に相当するデータ型です。 空白を作成するには BLANK 関数を使用し、空白かどうかをテストするには論理関数の ISBLANK を使用します。|  
  
 テーブル モデルには、多くの DAX 関数の入力または出力として使用される Table データ型が含まれています。 たとえば、FILTER 関数は、入力としてテーブルを受け取り、フィルター条件を満たした行のみを含んだ別のテーブルを出力します。 テーブル関数と集計関数を組み合わせることにより、動的に定義されるデータセットに対して複雑な計算を実行することができます。  
  
 通常、データ型は自動的に設定されますが、データ型とは何か、それらが特に DAX の数式においてどのように利用されているかを知ることは大切です。 たとえば、式のエラーや予期しない結果は、データ型に対して使用できない特定の演算子を引数に指定したことが原因で発生することが少なくありません。 たとえば、「 `= 1 & 2`」という数式では、文字列の結果 (12) が返されます。 これに対し、「 `= "1" + "2"`」という数式では、整数の結果 (3) が返されます。  
  
 テーブル モデルのデータ型とその明示的な変換および暗黙的な変換の詳細については、「[サポートされているデータ型 &#40;SSAS テーブル&#41;](data-types-supported-ssas-tabular.md)」を参照してください。  
  
##  <a name="bkmk_DAX_opertors"></a> DAX の演算子  
 DAX 言語では、次の 4 種類の計算演算子が数式に使用されます。  
  
-   比較演算子: 値を比較して論理 TRUE/FALSE 値を返します。  
  
-   算術演算子: 数値を返す算術計算を実行します。  
  
-   テキスト連結演算子: 2 つ以上のテキスト文字列を結合します。  
  
-   論理演算子: 複数の式を組み合わせて 1 つの結果を返します。  
  
 DAX の数式で使用される演算子の詳細については、次を参照してください。 [PowerPivot の DAX 演算子リファレンス](/dax/dax-operator-reference)します。  
  
##  <a name="bkmk_DAX_Formulas"></a> DAX の数式  
 計算列やメジャーに使用する計算を作成したり、行レベルのフィルターを使用してデータのセキュリティを確保するうえで、DAX の数式は欠かすことができません。 計算列やメジャーに使用する数式を作成するには、モデル デザイナー ウィンドウの上部に配置されている数式バーを使用します。 行フィルターに使用する数式を作成するには、[ロール マネージャー] ダイアログ ボックスを使用します。 このセクションの情報は、DAX の数式に関する基礎知識を初めての方にわかりやすく伝えることを目的としています。  
  
###  <a name="basics"></a> 数式の基本  
 DAX を使用すると、計算列の一部として、およびテーブルに関連付けられているメジャー (テーブルには直接表示されない) として、テーブル モデルの作成者がカスタム計算をモデル テーブルに定義できます。 また、モデル作成者がデータのセキュリティを確保できるのも DAX の利点です。ブール値を返す計算を作成し、特定の (または関連する) テーブルに関連付けられているロールのメンバー ユーザーがそのテーブルからクエリできる行を定義することができます。  
  
 DAX の数式には、非常に単純なものもあれば、きわめて複雑なものもあります。 次の表には、計算列で使用できる基本的な単純な数式の例を示しています。  
  
|||  
|-|-|  
|[数式]|説明|  
|`=TODAY()`|今日の日付をすべての行の列に挿入します。|  
|`=3`|値 3 を列のすべての行に挿入します。|  
|`=[Column1] + [Column2]`|同じ行の [Column1] と [Column2] の値を加算して、同じ行の計算列に結果を格納します。|  
  
 作成する式が単純か複雑かに関係なく、式は次の手順で作成できます。  
  
1.  各数式は等号から始める必要があります。  
  
2.  関数名を入力または選択するか、式を入力することができます。  
  
3.  目的の関数または名前の最初の数文字を入力すると、オートコンプリートによって使用可能な関数、テーブル、および列の一覧が表示されます。 Tab キーを押して、オートコンプリートの一覧の項目を数式に追加します。  
  
     また、 **[Fx]** ボタンをクリックして、使用可能な関数の一覧が表示することができます。 ボックスの一覧から関数を選択するには、方向キーを使用して項目を強調表示してから、 **[OK]** をクリックして数式に関数を追加します。  
  
4.  テーブルと列のボックスの一覧から選択するか、値を入力して、関数の引数を指定します。  
  
5.  構文エラーをチェックします。すべてのかっこが閉じられていることと、列、テーブル、および値が正しく参照されていることを確認してください。  
  
6.  Enter キーを押して数式を確定します。  
  
> [!NOTE]  
>  計算列の場合は、数式を確定し、その数式が有効であれば、すぐに列の値が格納されます。 メジャーの場合は、Enter キーを押すと、メジャー グリッドのメジャー定義がテーブルと共に保存されます。 数式が無効な場合は、エラーが表示されます。  
  
 次に示したのは、Days in Current Quarter という名前のメジャーに含まれる、より複雑な式の例です。  
  
```  
Days in Current Quarter:=COUNTROWS( DATESBETWEEN( 'Date'[Date], STARTOFQUARTER( LASTDATE('Date'[Date])), ENDOFQUARTER('Date'[Date])))  
```  
  
 このメジャーは、未完了の期間と前の期間との比較率を作成する際に使用されます。 数式では、経過した期間の比率を考慮に入れて、それを前の期間内の同じ比率と比較する必要があります。 この場合は、[Days Current Quarter to Date]/[Days in Current Quarter] とすることで、現行期間内の経過比率を割り出すことができます。  
  
 この数式は次の要素で構成されています。  
  
|数式の要素|説明|  
|---------------------|-----------------|  
|`Days in Current Quarter:=`|メジャーの名前。|  
|`=`|数式は等号 (=) で始まります。|  
|`COUNTROWS`|[COUNTROWS 関数&#40;DAX&#41; ](/dax/countrows-function-dax) 、Date テーブル内の行の数をカウント|  
|`()`|引数は、開きかっこと閉じかっこで指定します。|  
|`DATESBETWEEN`|DATESBETWEEN 関数は、Date テーブルの Date 列に存在する値ごとに、最終日までの日付を返します。|  
|`'Date'`|Date テーブルを指定します。 テーブルは単一引用符で囲みます。|  
|`[Date]`|Date テーブルの Date 列を指定します。 列は角かっこで囲みます。|  
|`,`||  
|`STARTOFQUARTER`|STARTOFQUARTER 関数は、四半期の開始日を返します。|  
|`LASTDATE`|LASTDATE 関数では、四半期の最後の日付を返します。|  
|`'Date'`|Date テーブルを指定します。|  
|`[Date]`|Date テーブルの Date 列を指定します。|  
|`,`||  
|`ENDOFQUARTER`|ENDOFQUARTER 関数|  
|`'Date'`|Date テーブルを指定します。|  
|`[Date]`|Date テーブルの Date 列を指定します。|  
  
#### <a name="using-formula-autocomplete"></a>数式のオートコンプリート機能の使用  
 モデル デザイナーの数式バーと数式の行フィルター ウィンドウ ([ロール マネージャー] ダイアログ ボックス) には、どちらもオートコンプリート機能が備わっています。 オートコンプリート機能によって、数式の各要素が選択肢として表示されるため、有効な式構文を効率的に入力することができます。  
  
-   数式のオートコンプリート機能は、関数が入れ子になっている既存の数式の途中で使用できます。 挿入ポイントの直前のテキストが、ドロップダウン リストに値を表示するために使用されます。挿入ポイントより後ろのすべてのテキストは変更されません。  
  
-   オートコンプリートには、関数の閉じかっこを追加する機能や、かっこを自動的に照合する機能はありません。 数式を保存または使用するには、各関数の構文に誤りがないことをユーザー自身が確認する必要があります。  
  
#### <a name="using-multiple-functions-in-a-formula"></a>数式での複数の関数の使用  
 関数は入れ子にすることができます。つまり、ある関数の結果を別の関数の引数として使用できます。 計算列では、最大で 64 レベルの関数を入れ子にできます。 ただし、入れ子化によって数式の作成やトラブルシューティングが困難になることがあります。  
  
 多くの関数は、入れ子になった関数としてのみ使用されるように設計されています。 これらの関数はテーブルを返します。このテーブルは、結果として直接保存することはできませんが、入力としてテーブル関数に渡す必要があります。 たとえば、SUMX 関数、AVERAGEX 関数、および MINX 関数には、第 1 引数としてテーブルが必要です。  
  
> [!NOTE]  
>  メジャーでは、関数の入れ子化にいくつかの制限があります。これらの制限は、列間の依存関係から必要になる多数の計算によるパフォーマンスへの影響を防ぐために設けられています。  
  
##  <a name="bkmk_DAX_functions"></a> DAX 関数  
 ここでは、DAX でサポートされる関数の *種類* の概要について説明します。 詳細については、「 [DAX 関数リファレンス](/dax/dax-function-reference)」を参照してください。  
  
 DAX には、日時を使った計算、条件値の作成、文字列の操作、リレーションシップに基づく参照を行うことのできる各種関数に加え、テーブル全体で繰り返し実行して再帰的な計算を行う機能が用意されています。 これらの関数の多くは、Excel の数式と非常によく似ています。ただし、DAX の数式は、次の点が大きく異なります。  
  
-   DAX 関数は、常に列全体またはテーブル全体を参照します。 テーブルまたは列の特定の値のみを使用する場合は、数式にフィルターを追加できます。  
  
-   行ごとに計算をカスタマイズする場合は、現在の行の値か関連する値を一種のパラメーターとして使用できる DAX の関数を使用します。これによって、コンテキストによって変化する計算を実行できます。 これらの関数のしくみを理解するには、後のトピックの「DAX の数式のコンテキスト」を参照してください。  
  
-   DAX には、値ではなくテーブルを返す多くの関数が含まれています。 テーブルはレポート クライアントには表示されませんが、他の関数の入力として使用されます。 たとえば、テーブルを取得して、含まれる個別値をカウントしたり、フィルター処理されたテーブルまたは列における動的な合計を計算したりすることができます。  
  
-   DAX 関数には、さまざまな *タイム インテリジェンス* 関数が含まれます。 これらの関数を使用すると、日付範囲を定義または選択して、それらの日付または範囲に基づく動的な計算を実行できます。 たとえば、並列期間の合計を比較できます。  
  
### <a name="date-and-time-functions"></a>日付と時刻の関数  
 DAX の日付と時刻の関数は、Microsoft Excel の日付と時刻の関数に似ています。 ただし、DAX 関数は、Microsoft SQL Server で使用される `datetime` データ型に基づいています。 詳細については、次を参照してください。[日付と時刻関数&#40;DAX&#41;](/dax/date-and-time-functions-dax)します。  
  
### <a name="filter-functions"></a>フィルター関数  
 DAX のフィルター関数を使用すると、特定のデータ型を返したり、関連テーブルで値を参照したり、関連する値によるフィルターを適用したりすることができます。 参照関数では、データベースと同様、テーブルおよびリレーションシップを使用します。 フィルター関数を使用すると、データ コンテキストを操作して、動的な計算を実行できます。 詳細については、次を参照してください。[フィルター関数&#40;DAX&#41;](/dax/filter-functions-dax)します。  
  
### <a name="information-functions"></a>情報関数  
 情報関数は、引数として渡されたセルまたは行を参照し、値が必要な型と一致するかどうかを通知します。 たとえば、ISERROR 関数は、参照する値にエラーが含まれている場合に TRUE を返します。 詳細については、次を参照してください。[情報関数&#40;DAX&#41;](/dax/information-functions-dax)します。  
  
### <a name="logical-functions"></a>論理関数  
 論理関数は、式に対して操作を実行し、その式の値に関する情報を返します。 たとえば、TRUE 関数を使用すると、評価対象の式が TRUE 値を返すかどうかがわかります。 詳細については、次を参照してください。[論理関数&#40;DAX&#41;](/dax/logical-functions-dax)します。  
  
### <a name="mathematical-and-trigonometric-functions"></a>数学関数と三角関数  
 DAX の数学関数は、Excel の数学関数や三角関数と非常によく似ています。 ただし DAX 関数で使用する数値データ型には、小さな違いがいくつかあります。 詳細については、次を参照してください。[数学関数や三角関数&#40;DAX&#41;](/dax/math-and-trig-functions-dax)します。  
  
### <a name="statistical-functions"></a>統計関数  
 DAX には、集計を行う統計関数があります。 DAX では、集計と平均の作成や最小値と最大値の特定に加えて、集計前に列をフィルター処理したり、関連テーブルに基づき集計を作成したりすることができます。 詳細については、次を参照してください。[統計関数&#40;DAX&#41;](/dax/statistical-functions-dax)します。  
  
### <a name="text-functions"></a>文字列関数  
 DAX の文字列関数は、Excel の文字列関数と非常によく似ています。 文字列の一部を返したり、文字列内のテキストを検索したり、文字列値を連結したりすることができます。 さらに、DAX には日付、時刻、数値の形式を制御する関数も用意されています。 詳細については、次を参照してください。[テキスト関数&#40;DAX&#41;](/dax/text-functions-dax)します。  
  
### <a name="time-intelligence-functions"></a>タイム インテリジェンス関数  
 DAX に含まれるタイム インテリジェント関数を使用すると、カレンダーおよび日付に関して組み込まれた知識を使用する計算を作成できます。 時刻と日付の範囲を集計や計算と一緒に使用することで、比較可能な複数期間の売上、在庫などに関する有意な比較を構築できます。 詳細については、次を参照してください。[タイム インテリジェンス関数&#40;DAX&#41;](/dax/time-intelligence-functions-dax)します。  
  
###  <a name="bkmk_TableFunc"></a> テーブル値関数  
 DAX 関数には、テーブルを出力する関数、入力としてテーブルを受け取る関数、またはその両方を行う関数が存在します。 テーブルに含めることができるのは 1 列であるため、テーブル値関数も入力として 1 列を受け取ります。 DAX の数式を最大限に活用するには、このようなテーブル値関数の使い方を理解することが大切です。 DAX には、次の種類のテーブル値関数があります。  
  
 **フィルター関数** 現在の行に関連する列、テーブル、または値を返します。  
  
 **集計関数** テーブルの複数の行にわたって式を集計します。  
  
 **タイム インテリジェンス関数** 日付のテーブルを返すか、集計の計算に日付のテーブルを使用します。  
  
##  <a name="bkmk_context"></a> DAX の数式のコンテキスト  
 DAX を使用して数式を作成する場合、*コンテキスト* の概念を理解することが重要です。 コンテキストを使用すると動的分析を行うことができます。数式の結果は、現在の行またはセルの選択や関連データを反映して変化するためです。 高性能な動的分析の作成や、数式に関する問題のトラブルシューティングを行うには、コンテキストをよく理解して効果的に使用することが重要です。  
  
 テーブル モデルの数式は、次のような設計要素に対応して、さまざまなコンテキストで評価されます。  
  
-   ピボットテーブルやレポートに適用されるフィルター  
  
-   数式内で定義されているフィルター  
  
-   数式内で特別な関数を使用して指定されたリレーションシップ  
  
 コンテキストには、 *行コンテキスト*、 *クエリ コンテキスト*、 *フィルター コンテキスト*という種類があります。  
  
###  <a name="bkmk_row_context"></a> 行コンテキスト  
 *行コンテキスト*"current row"と見なすことができます。 計算列に数式を作成した場合、その数式の行コンテキストは、現在の行内の全列からの値を含んでいます。 テーブルが別のテーブルに関連付けられている場合、コンテキストには、現在の行に関連付けられている他のテーブルの値もすべて含まれます。  
  
 たとえば、同じテーブルの Freight と Tax の 2 つの列の値を加算する `=[Freight] + [Tax]`という計算列を作成したとします。 この数式は、指定した列の現在の行の値のみを自動的に取得します。  
  
 行コンテキストは、テーブル間に定義されたリレーションシップ (DAX 数式を使用して計算列に定義されているリレーションシップも含む) を使用して、関連するテーブルのどの行が現在の行に関連付けられているかを判別します。  
  
 たとえば次の数式は、RELATED 関数を使用し、注文の出荷先の地域に基づいて、関連テーブルから税の値をフェッチします。 現在のテーブル内の地域の値を使用し、関連するテーブルで地域を探し、関連するテーブルから該当する地域の税率を取得することによって、税の値が求められます。  
  
```  
= [Freight] + RELATED('Region'[TaxRate])  
```  
  
 この数式は、Region テーブルから現在の地域の税率を取得し、Freight 列の値に加算します。 DAX の数式では、テーブルどうしを関連付ける特定のリレーションシップを知る必要や指定する必要はありません。  
  
#### <a name="multiple-row-context"></a>複数行のコンテキスト  
 DAX には、テーブルで計算を繰り返し実行する関数が含まれています。 これらの関数は、現在の行と、それぞれの行コンテキストを持つことができます。  基本的には、これらの関数を使用すると、内側ループと外側ループに関して再帰的に実行する数式を作成できます。  
  
 たとえば、 **Products** と **Sales** という 2 つのテーブルがブックに含まれている場合に、 複数の製品に関連する取引が多数存在する sales テーブル全体から、各製品の 1 回の取引あたりの最大注文数を検索するとします。  
  
 DAX を使用すると、正しい値を返す 1 つの数式を作成でき、データをテーブルに追加すると結果が自動的に更新されます。  
  
```  
=MAXX(FILTER(Sales,[ProdKey]=EARLIER([ProdKey])),Sales[OrderQty])  
```  
  
 この数式の詳細なチュートリアルについてを参照してください。、 [EARLIER 関数](/dax/earlier-function-dax)します。  
  
 つまり、EARLIER 関数は、現在の操作に先行する操作からの行コンテキストを格納します。 この関数は常に、メモリに 2 つのコンテキスト セットを格納します。1 つのコンテキスト セットは、数式の内側のループに対する現在行を表し、もう一方のセットは、数式の外側のループに対する現在行を表します。 DAX では、2 つのループの間で値が自動的に提供されるので、複雑な集計を作成することができます。  
  
####  <a name="bkmk_query_context"></a> クエリ コンテキスト  
 *クエリ コンテキスト* とは、数式に対して暗黙的に取得されるデータのサブセットを指します。 テーブル モデルに基づくレポートまたはピボットテーブルに、メジャーまたは他の値のフィールドを配置すると、エンジンが、行見出しと列見出し、スライサー、およびレポート フィルターを調べてコンテキストを決定します。 次に、必要なクエリがデータ ソースに対して実行され、データの正しいサブセットを取得し、数式で定義された計算を行い、ピボットテーブルの各セルまたはレポートに値を含めます。 取得されるデータのセットは、各セルのクエリ コンテキストです。  
  
> [!WARNING]  
>  DirectQuery クエリ モードのモデルでは、コンテキストが評価されると、データの正しいサブセットを取得して結果を計算するセット演算が、SQL ステートメントに変換されます。 これらのステートメントは、直接リレーショナル データ ストアに対して実行されます。 したがって、データを取得して結果を計算する方法は異なりますが、コンテキストそのものは変わりません。  
  
 数式を指定する場所によってコンテキストが変わるため、数式の結果も変わる可能性があります。  
  
 たとえば、 **Sales** テーブルの **Profit** 列の値を合計する `=SUM('Sales'[Profit])`という数式を作成したとします。  この数式を **Sales** テーブル内の計算列で使用した場合、数式の結果はテーブル全体について同じになります。なぜなら、この数式のクエリ コンテキストは常に **Sales** テーブルのデータセット全体であるためです。 計算結果には、すべての地域、すべての製品、すべての年度の利益が含まれます。  
  
 ただし、同じ結果を何百回も表示する必要はなく、特定の年度、特定の国、特定の製品、または、そうした条件の組み合わせについて、該当する利益を計算し、総計を求めるのが普通です。  
  
 実際、ピボットテーブルで、列ヘッダーや行ヘッダー、スライサーを追加したり削除したりすると、コンテキストが変わります。 ピボットテーブルに列または行の見出しを追加するたびに、メジャーが評価されるクエリ コンテキストが変化します。 スライス操作やフィルター処理もコンテキストに影響を及ぼします。 したがって、メジャーで使用される同じ数式は、セルごとに異なる *クエリ コンテキスト* で評価されます。  
  
####  <a name="bkmk_filter_context"></a> フィルター コンテキスト  
 *フィルター コンテキスト* は、各列が含むことができる値のセット、または関連するテーブルから取得される値が含むことができる値のセットです。 フィルターを適用できるのは、デザイナーまたはプレゼンテーション層 (レポートおよびピボットテーブル) の列です。 また、数式内のフィルター式によって明示的に定義することもできます。  
  
 フィルター コンテキストは、数式の引数を使用して列やテーブルの使用可能な値のセットにフィルター制約を指定すると追加されます。 行コンテキストやクエリ コンテキストなど、他のコンテキストに加えて適用されます。  
  
 テーブル モデルには、フィルター コンテキストを作成する多くの方法があります。 モデルを使用できるクライアント ( [!INCLUDE[ssCrescent](../../includes/sscrescent-md.md)] レポートなど) のコンテキストでは、行ヘッダーや列ヘッダーにスライサーまたはレポート フィルターを追加して、即座にフィルターを作成できます。 数式にフィルター式を直接指定することもできます。それにより、関連する値を指定したり、入力として使用されるテーブルにフィルターを設定したり、計算で使用される値のコンテキストを動的に取得したりします。 また、フィルターを完全にクリアしたり、特定の列のフィルターを選択的にクリアしたりすることもできます。 これは、総計を計算する数式を作成するときに非常に便利です。  
  
 数式内にフィルターを作成する方法の詳細については、次を参照してください。、[フィルター関数](/dax/filter-function-dax)します。  
  
 フィルターをクリアする方法の例については総計を作成するには、「、[すべて関数](/dax/all-function-dax)します。  
  
 選択的にクリアして、数式内にフィルターを適用する方法の例については、次を参照してください。、 [ALLEXCEPT 関数](/dax/allexcept-function-dax)します。  
  
####  <a name="bkmk_determine_context"></a> 数式のコンテキストの決定  
 DAX 数式を作成すると、構文が有効かどうかが最初にテストされます。次に、数式に含まれる列やテーブルの名前が現在のコンテキストで見つかるかどうかがテストされます。 数式に指定された列またはテーブルが見つからない場合は、エラーが返されます。  
  
 検証中のコンテキスト (および再計算操作) は、前のセクションで説明したように、モデル内の使用可能なテーブル、テーブル間のリレーションシップ、および適用されたフィルターを使用して決定されます。  
  
 たとえば、新しいテーブルにデータをインポートしたばかりで、そのテーブルが他のテーブルには関連していない場合 (フィルターもまだ適用していない場合)、 *現在のコンテキスト* はテーブルの列セット全体になります。 テーブルがリレーションシップによって別のテーブルに関連付けられている場合、現在のコンテキストには、関連付けられているテーブルも含まれます。 このテーブルの列をレポートに追加し、そのレポートにスライサーとレポート フィルターが含まれる場合、数式のコンテキストは、レポートの各セルのデータのサブセットになります。  
  
 コンテキストは、数式のトラブルシューティングも困難にする可能性がある強力な概念です。 コンテキストの動作を理解するには、単純な数式とリレーションシップから始めることをお勧めします。 次のセクションでは、数式でさまざまなタイプのコンテキストを使用して動的に結果を返す方法の例も示します。  
  
##### <a name="examples-of-context-in-formulas"></a>数式のコンテキストの例  
  
1.  [RELATED 関数](/dax/related-function-dax)関数は、関連する列に値を含めるには、現在の行のコンテキストを拡大します。 これにより、参照を実行できます。 このトピックには、フィルター処理と行コンテキストの相互作用の例が含まれています。  
  
2.  [フィルター関数](/dax/filter-function-dax)関数を使用して、現在のコンテキストに含める行を指定できます。 このトピックの例では、集計を行う別の関数にフィルターを埋め込む方法も示されています。  
  
3.  [すべて関数](/dax/all-function-dax)関数を数式内でコンテキストを設定します。 この関数を使用すると、クエリ コンテキストの結果として適用されたフィルターをオーバーライドできます。  
  
4.  [ALLEXCEPT 関数](/dax/allexcept-function-dax)関数を使用して、指定した 1 つを除くすべてのフィルターを削除できます。 どちらのトピックにも、数式の作成と複雑なコンテキストの理解に役立つ例が含まれています。  
  
5.  [EARLIER 関数](/dax/earlier-function-dax)と[EARLIEST 関数](/dax/earliest-function-dax)関数、内側のループの値を参照しながら、計算を実行してテーブルをループするようにします。 再帰の概念や内側と外側のループについてよく知っている場合は、このトピックを読むと EARLIER および EARLIEST 関数の威力がわかります。 これらの概念についてよく知らなくても、例の手順に注意して従うことで、計算で内側と外側のコンテキストがどのように使用されるのかを理解できます。  
  
##  <a name="bkmk_RelModel"></a> 数式とテーブル モデル  
 [!INCLUDE[ssBIDevStudioFull](../../includes/ssbidevstudiofull-md.md)]のモデル デザイナーは、複数のテーブルのデータを使用して作業を行う場所であり、テーブル モデルでテーブルの関連付けを行う場所です。 このモデルでは、共通の値 (キー) を含む列のリレーションシップによってテーブルが結合されます。 テーブル モデルでは、他のテーブルの列に値をリンクして、より有益な計算を行うことができます。 リレーショナル データベースと同様に、関連するテーブルの多くのレベルを結び付け、任意のテーブルの列を結果で使用できます。  
  
 たとえば、売上テーブル、製品テーブル、および製品カテゴリ テーブルをリンクすると、ユーザーは、ピボットテーブルやレポートで、列のさまざまな組み合わせを使用できます。 関連するフィールドは、接続されたテーブルをフィルター処理したり、サブセットに対する計算を作成したりするために使用できます (リレーショナル データベースや、テーブルと結合の操作に詳しくない場合は、「[リレーションシップ &#40;SSAS テーブル&#41;](relationships-ssas-tabular.md)」を参照してください)。  
  
 テーブル モデルでは、複数のテーブル間での複数のリレーションシップがサポートされます。 混乱や結果の間違いを避けるために、アクティブなリレーションシップとして一度に指定できるリレーションシップは 1 つだけですが、必要に応じてアクティブなリレーションシップを変更し、データのさまざまな組み合わせを計算で使用することができます。 [USERELATIONSHIP 関数&#40;DAX&#41; ](/dax/userelationship-function-dax)特定の計算で使用する 1 つまたは複数のリレーションシップを指定するために使用できます。  
  
 テーブル モデルの数式は、以下の規則に従って設計する必要があります。  
  
-   複数のテーブルがリレーションシップによって関連付けられている場合、キーとして使用される 2 つの列の値が一致することを確認する必要があります。 ただし、参照整合性は強制されないため、キー列に一致しない値があってもリレーションシップを作成できます。 その場合は、空白または一致しない値のために、数式の結果が影響を受けることがあります。  
  
-   リレーションシップを使用してモデル内のテーブルをリンクする場合は、数式を評価するスコープ (または *コンテキスト*とも呼ばれる) が拡大されます。 新しいテーブルや新しいリレーションシップを追加したため、またはアクティブなリレーションシップを変更したためにコンテキストが変化すると、予測していなかった結果の変更が生じることがあります。 詳細については、このトピックの「 [DAX の数式のコンテキスト](#bkmk_context) 」を参照してください。  
  
##  <a name="bkmk_tables"></a> テーブルと列の操作  
 テーブル モデルにおけるテーブルは、外観が Excel テーブルと似ていますが、データや数式を処理する方法は異なります。  
  
-   数式では、テーブルおよび列のみを使用できます。個々のセル、範囲参照、配列などは使用できません。  
  
-   数式では、リレーションシップを使用して関連するテーブルから値を取得できます。 取得した値は、常に現在の行の値に関連しています。  
  
-   Excel ワークシートとは異なり、不規則データを含めることはできません。 テーブル内の各行には同じ数の列が含まれている必要があります。 ただし、一部の列には空の値を含めることができます。 Excel データ テーブルと、テーブル モデルのデータ テーブルを置き換えることはできません。  
  
-   各列のデータ型は設定されているので、それぞれの列の値は、その型と同じである必要があります。  
  
### <a name="referring-to-tables-and-columns-in-formulas"></a>数式でのテーブルと列の参照  
 テーブルと列はその名前を使用して参照できます。 たとえば、次の数式は *完全修飾* 名を使用して 2 つのテーブルの列を参照する方法を示しています。  
  
```  
=SUM('New Sales'[Amount]) + SUM('Past Sales'[Amount])  
```  
  
 モデル デザイナーで数式を評価すると、最初に全般的な構文がチェックされます。その後、指定した列およびテーブルの名前がチェックされ、現在のコンテキストに適合しているかどうか照合されます。 名前があいまいな場合や、列またはテーブルが見つからない場合は、数式がエラーになります (エラーが発生したセルでは、データ値の代わりに #ERROR という文字列が表示されます)。 テーブル、列、およびその他のオブジェクトの名前付け要件に関する詳細については、「名前付けに関する要件」を参照してください[PowerPivot の DAX 構文の仕様](/dax/dax-syntax-reference)します。  
  
### <a name="table-relationships"></a>テーブルのリレーションシップ  
 テーブル間のリレーションシップを作成すると、別のテーブルのデータを参照して関連する値を使用し、複雑な計算を行うことができます。 たとえば、計算列を使用して、現在の再販業者に関連する出荷レコードをすべて検索してから、それぞれの輸送費を合計することができます。 ただし、多くの場合、リレーションシップは必要ありません。 数式内で LOOKUPVALUE 関数を使用して、 *search_column* および *search_value* パラメーターで指定された条件を満たす行の *result_columnName* の値を返すことができます。  
  
 DAX 関数の多くでは、参照先の列を見つけて意味のある結果を返すために、テーブル間のリレーションシップが必要になります。 リレーションシップを特定しようとする関数もありますが、最適な結果を得るには、可能な限りリレーションシップを作成するようにしてください。 詳細については、このトピックの「 [数式とテーブル モデル](#bkmk_RelModel) 」を参照してください。  
  
##  <a name="bkmk_RefreshRecalc"></a> 数式の結果の更新 (処理)  
 *データ処理* と *再計算* は、別個の操作ですが互いに関連しています。 複雑な数式、大量のデータ、または外部データ ソースから取得されるデータを含むモデルをデザインする場合には、これらの概念を十分理解している必要があります。  
  
 *データ処理* は、外部データ ソースの新しいデータでモデル内のデータを更新する処理です。  
  
 *再計算* は、数式自体に対する変更と基になるデータの変更を反映するために、数式の結果を更新する処理です。 再計算は、以下のようにパフォーマンスに影響を及ぼす場合があります。  
  
-   集計列の値が計算され、モデルに格納されます。 計算列の値を更新するには、-完全処理、データの処理、または再計算の処理の 3 つの処理コマンドのいずれかを使用してモデルを処理する必要があります。 数式が変更された場合、列全体に対して、常に数式の結果を再計算する必要があります。  
  
-   メジャーによって計算される値は、ユーザーがメジャーをピボットテーブルに追加したときやレポートを開いたときに動的に評価されます。ユーザーがコンテキストを変更すると、メジャーによって返される値は変化します。 メジャーの結果には、常に最新のメモリ内キャッシュが反映されます。  
  
 再計算の結果、異なる値が返され、ロール メンバーによる行のクエリの可否が変化しない限り、処理も再計算も行フィルターの数式には影響しません。  
  
 詳細については、「 [データの処理 (SSAS テーブル)](../process-data-ssas-tabular.md)」を参照してください。  
  
##  <a name="bkmk_troubleshoot"></a> 数式内のエラーのトラブルシューティング  
 数式を定義するときにエラーが発生した場合は、その数式に *構文エラー*、 *セマンティック エラー*、または *計算エラー*が含まれている可能性があります。  
  
 構文エラーの解決は非常に簡単です。 かっこやコンマが不足している場合がよくあります。 個々の関数の構文については、「 [DAX 関数リファレンス](/dax/dax-function-reference)」を参照してください。  
  
 構文は正しいが、参照される値または列が数式のコンテキストで意味をなさないときには、別のエラーが発生します。 このようなセマンティック エラーや計算エラーは次のような問題が原因で生じている可能性があります。  
  
-   数式が、存在しない列、テーブル、または関数を参照している。  
  
-   数式は正しいように見えるが、データ エンジンがデータをフェッチしたときに型の不一致が検出され、エラーが発生する。  
  
-   数式が関数に渡したパラメーターの数または型が正しくない。  
  
-   数式が参照している別の列にエラーがあるため、その値が無効になる。  
  
-   数式が参照している列が処理されなかった。メタデータは含まれるが、計算するための実際のデータが含まれない。  
  
 最初の 4 つのケースでは、DAX は無効な数式を含んでいる列全体にフラグを設定します。 最後のケースでは、DAX は列をグレーで表示し、その列が未処理状態であることを示します。  
  
##  <a name="bkmk_addional_resources"></a> その他のリソース  
 「[テーブル モデリング &#40;Adventure Works チュートリアル&#41;](../tabular-modeling-adventure-works-tutorial.md)」では、計算列、メジャー、および行フィルターに多数の計算を含んだテーブル モデルの作成手順について説明します。 ほとんどの数式について、それぞれの目的が説明されています。  
  
 [Analysis Services と PowerPivot チームのブログ](https://go.microsoft.com/fwlink/?LinkID=220949&clcid=0x409)に関する情報、ヒント、ニュース、お知らせを提供します。[!INCLUDE[ssASCurrent](../../includes/ssascurrent-md.md)]および PowerPivot です。  
  
 「 [DAX リソース センター](https://go.microsoft.com/fwlink/?LinkID=220966&clcid=0x409) 」には、マイクロソフト内外の DAX 情報が掲載されています。中には、ビジネス インテリジェンスの第一線で活躍する専門家による DAX に関する豊富なソリューションも紹介されています。  
  
## <a name="see-also"></a>参照  
 [Data Analysis Expressions &#40;DAX&#41;リファレンス](/dax/data-analysis-expressions-dax-reference)   
 [メジャー &#40;SSAS テーブル&#41;](measures-ssas-tabular.md)   
 [計算列 &#40;SSAS テーブル&#41;](ssas-calculated-columns.md)   
 [ロール &#40;SSAS テーブル&#41;](roles-ssas-tabular.md)   
 [KPI &#40;SSAS テーブル&#41;](kpis-ssas-tabular.md)   
 [サポートされているデータ ソース &#40;SSAS テーブル&#41;](data-sources-supported-ssas-tabular.md)  
  
  
