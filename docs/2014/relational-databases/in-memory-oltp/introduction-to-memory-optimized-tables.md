---
title: メモリ最適化テーブルの概要 | Microsoft Docs
ms.custom: ''
ms.date: 07/14/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: ef1cc7de-63be-4fa3-a622-6d93b440e3ac
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: ff434efd0a9f4fcb3316143e598e636bff85f487
ms.sourcegitcommit: 3026c22b7fba19059a769ea5f367c4f51efaf286
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/15/2019
ms.locfileid: "63157839"
---
# <a name="introduction-to-memory-optimized-tables"></a>メモリ最適化テーブルの概要
  メモリ最適化テーブルは、[CREATE TABLE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-table-transact-sql) を使用して作成されるテーブルです。  
  
 メモリ最適化テーブルはメモリ内に存在します。 テーブルの行は、メモリから読み込まれ、メモリに書き込まれます。 テーブル全体もメモリに存在します。 ディスク上にはテーブル データの 2 番目のコピーが保持されますが、持続性を実現するためのものにすぎません。  
  
 インメモリ OLTP は、開発、配置、管理、サポートなど、すべての領域においてシームレスな使用環境を提供するために、 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] と統合されています。 データベースには、ディスク ベースのオブジェクトと同様にインメモリのオブジェクトを含めることができます。  
  
 メモリ最適化テーブル内の行には、バージョンが付いています。 これは、テーブルの各行に複数のバージョンが存在する可能性があることを意味します。 行バージョンはいずれも、同じテーブル データ構造で保持されます。 行のバージョン管理は、同じ行に対して読み取りと書き込みを同時に実行できるようにするために使用します。 詳細については、同時読み取りと書き込みが同じ行には、次を参照してください。[メモリ最適化テーブルでのトランザクション](memory-optimized-tables.md)です。  
  
 次の図は、複数バージョン管理について説明したものです。 この図では、行が 3 つあるテーブルを示しています。行のそれぞれに、バージョンが複数存在します。  
  
 ![複数バージョン管理。](../../database-engine/media/hekaton-tables-1.gif "複数バージョン管理。")  
  
 テーブルには、r1、r2、および r3 の 3 行があります。 r1 には 3 つ、r2 には 2 つ、r3 には 4 つのバージョンがあります。 同じ行に複数のバージョンがある場合にも、メモリ上の場所が連続しているとは限らないことに注意してください。 バージョンの異なる行がテーブル データ構造のさまざまな場所に分散して配置されていることもあります。  
  
 メモリ最適化テーブルのデータ構造は、行バージョンのコレクションと考えることができます。 ディスク ベース テーブルの行がページとエクステントによって整理され、個々の行がページ番号とページ オフセットでアドレス指定されているのに対して、メモリ最適化テーブルの行バージョンは、8 バイトのメモリ ポインターを使用してアドレスが指定されています。  
  
## <a name="durability"></a>Durability  
 メモリ最適化テーブルには既定で完全持続性があり、メモリ最適化テーブルに対する完全持続性トランザクションは、(従来の) ディスクベース テーブルのトランザクションと同様に、完全なアトミック性、一貫性、分離性、持続性 (ACID) を備えています。 メモリ最適化テーブルおよびネイティブ コンパイル ストアド プロシージャは [!INCLUDE[tsql](../../../includes/tsql-md.md)]のサブセットをサポートします。  
  
 インメモリ OLTP ではトランザクションの持続性が遅延している状態の持続性テーブルがサポートされます。 遅延持続性トランザクションは、トランザクションがコミットした後すぐにディスクに保存されます。 ディスクに保存せずにコミットされたトランザクションは、パフォーマンスは向上しますが、サーバー クラッシュまたはフェールオーバー時に失われてしまいます。  
  
 既定の持続性を持つメモリ最適化テーブルだけでなく、 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] は、記録やディスクへのデータ保存が行われない持続性のないメモリ最適化テーブルをサポートします。 つまり、これらのテーブルのトランザクションはディスク IO を必要としませんが、サーバーのクラッシュまたはフェールオーバーが発生した場合、データを復旧できません。  
  
## <a name="accessing-data-in-memory-optimized-tables"></a>メモリ最適化テーブルのデータへのアクセス  
 メモリ最適化テーブルのデータには、次の 2 つの方法でアクセスできます。  
  
-   解釈を通じて[!INCLUDE[tsql](../../../includes/tsql-md.md)](ネイティブ コンパイル ストアド プロシージャ) の外部でします。 これらの [!INCLUDE[tsql](../../../includes/tsql-md.md)] ステートメントは、解釈されたストアド プロシージャ内にあっても、アドホック [!INCLUDE[tsql](../../../includes/tsql-md.md)] ステートメントであってもかまいません。  
  
-   ネイティブ コンパイル ストアド プロシージャを経由してアクセスできます。  
  
 メモリ最適化テーブルには、ネイティブ コンパイル ストアド プロシージャ (「[ネイティブ コンパイル ストアド プロシージャ](natively-compiled-stored-procedures.md)」) からアクセスするのが最も効率的です。 メモリ最適化テーブルのデータには、(従来の) 解釈された [!INCLUDE[tsql](../../../includes/tsql-md.md)]でもアクセスできます。 解釈された [!INCLUDE[tsql](../../../includes/tsql-md.md)] とは、ネイティブ コンパイル ストアド プロシージャを使用せずにメモリ最適化テーブルにアクセスすることを表します。 解釈された [!INCLUDE[tsql](../../../includes/tsql-md.md)] アクセスの例として、DML トリガー、アドホック [!INCLUDE[tsql](../../../includes/tsql-md.md)] バッチ、ビュー、およびテーブル値関数からのメモリ最適化テーブルへのアクセスがあります。  
  
 次の表に、さまざまなオブジェクトへのネイティブ アクセスおよび解釈された [!INCLUDE[tsql](../../../includes/tsql-md.md)] アクセスを示します。  
  
|機能|ネイティブ コンパイル ストアド プロシージャを使用したアクセス|解釈された [!INCLUDE[tsql](../../../includes/tsql-md.md)] アクセス|CLR アクセス|  
|-------------|-------------------------------------------------------|-------------------------------------------|----------------|  
|メモリ最適化テーブル|はい|はい|不可 <sup>1</sup>|  
|[メモリ最適化テーブル変数](../../database-engine/memory-optimized-table-variables.md)|はい|[はい]|いいえ|  
|[ネイティブ コンパイル ストアド プロシージャ](https://msdn.microsoft.com/library/dn133184.aspx)|EXECUTE ステートメントを使用してネイティブ コンパイル ストアド プロシージャからストアド プロシージャを実行することはできません。|はい|不可 <sup>1</sup>|  
  
 <sup>1</sup>コンテキスト接続からメモリ最適化テーブルまたはネイティブ コンパイル ストアド プロシージャにアクセスすることはできません (から接続[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]CLR モジュールを実行する場合)。 ただし、別の接続を作成して開き、そこからメモリ最適化テーブルおよびネイティブ コンパイル ストアド プロシージャにアクセスできます。 詳細については、次を参照してください。[正規 vs します。コンテキスト接続](../clr-integration/data-access/context-connections-vs-regular-connections.md)します。  
  
## <a name="performance-and-scalability"></a>パフォーマンスとスケーラビリティ  
 インメモリ OLTP を使用することで実現できるパフォーマンスの向上には、次の要素が影響します。  
  
 通信  
 短いストアド プロシージャに対する多数の呼び出しを実行するアプリケーションは、各ストアド プロシージャにより多くの機能が実装されて呼び出しが少なくて済むアプリケーションと比較した場合、パフォーマンス向上の点で劣る場合があります。  
  
 [!INCLUDE[tsql](../../../includes/tsql-md.md)] の実行  
 インメモリ OLTP は、解釈されたストアド プロシージャやクエリ実行ではなく、ネイティブ コンパイル ストアド プロシージャを使用する場合に、最高のパフォーマンスを発揮します。 他のストアド プロシージャを実行するストアド プロシージャをネイティブでコンパイルすることはできませんが、そのようなストアド プロシージャからメモリ最適化テーブルにアクセスすると有利な場合もあります。  
  
 範囲スキャンとポイント参照  
 メモリ最適化された非クラスター化インデックスでは、範囲スキャンと並べ替えられたスキャンがサポートされています。 ポイント参照については、メモリ最適化された非クラスター化インデックスよりもメモリ最適化されたハッシュ インデックスの方がパフォーマンスが優れています。 メモリ最適化された非クラスター化インデックスはディスク ベース インデックスよりもパフォーマンスが優れています。  
  
 インデックス操作はログに記録されず、メモリ内にのみ存在します。  
  
 コンカレンシー  
 ラッチの競合やブロックなど、エンジンレベルのコンカレンシーがパフォーマンスに影響するアプリケーションの場合、アプリケーションをインメモリ OLTP に移行するとパフォーマンスが大幅に向上します。  
  
 次の表は、リレーショナル データベースで一般的に生じるパフォーマンスとスケーラビリティの問題、およびインメモリ OLTP によってどのようにパフォーマンスが向上するかを示しています。  
  
|問題点|インメモリ OLTP の影響|  
|-----------|----------------------------|  
|パフォーマンス<br /><br /> リソース (CPU、I/O、ネットワーク、またはメモリ) の使用率が高い。|CPU<br /> ネイティブ コンパイル ストアド プロシージャは、解釈されたストアド プロシージャに比較すると [!INCLUDE[tsql](../../../includes/tsql-md.md)] ステートメントを実行するために必要な命令数が少ないため、CPU の使用率を大幅に下げることができます。<br /><br /> インメモリ OLTP では、1 台のサーバーで 5 ～ 10 台のサーバーのスループットに対応できる可能性があるため、スケールアウトしたワークロード環境でのハードウェア投資を削減できます。<br /><br /> I/O<br /> データやインデックス ページに対する処理に起因する I/O のボトルネックが発生する場合、インメモリ OLTP ではボトルネックを低減できます。 また、インメモリ OLTP オブジェクトのチェックポイント処理は連続的であり、I/O 操作の突然の増加を招くことはありません。 ただし、パフォーマンス クリティカルなテーブルのワーキング セットがメモリに収まらない場合、インメモリ OLTP では、データがメモリ常駐型であることが必要であるため、パフォーマンスは向上しません。 ログ記録で I/O のボトルネックが発生する場合、インメモリ OLTP はログ記録が少ないためボトルネックを軽減できます。 1 つ以上のメモリ最適化テーブルが持続性のないテーブルとして構成されている場合は、データのログ記録を無効にできます。<br /><br /> Memory<br /> インメモリ OLTP では、パフォーマンス上の利点は得られません。 インメモリ OLTP では、オブジェクトがメモリ常駐型であることが必要になるため、メモリの負荷が増加する可能性があります。<br /><br /> ネットワーク<br /> インメモリ OLTP では、パフォーマンス上の利点は得られません。 データは、データ層からアプリケーション層に渡す必要があります。|  
|スケーラビリティ<br /><br /> [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] アプリケーションでのスケーリングの問題のほとんどは、ロック、ラッチ、スピンロックの競合など、同時実行の問題が原因です。|ラッチの競合<br /> 一般的なシナリオとして、キー順に行を同時に挿入した場合の、インデックスの最終ページでの競合を挙げることができます。 インメモリ OLTP では、データへのアクセス時にラッチを使用しないため、ラッチの競合に関連するスケーラビリティの問題は完全になくなります。<br /><br /> スピンロックの競合<br /> インメモリ OLTP では、データへのアクセス時にラッチを使用しないため、スピンロックの競合に関連するスケーラビリティの問題は完全になくなります。<br /><br /> ロックに関連する競合<br /> データベース アプリケーションで読み取り操作と書き込み操作の間にブロックの問題が発生した場合、インメモリ OLTP では、新しい形式のオプティミスティック コンカレンシーを使用してすべてのトランザクション分離レベルを実装するため、ブロックの問題は排除されます。 インメモリ OLTP では行バージョンを格納するために TempDB は使用されません。<br /><br /> 2 つの同時実行トランザクションで同じ行を更新しようとした場合など、2 つの書き込み操作間の競合によってスケーリングの問題が発生した場合、インメモリ OLTP では、一方のトランザクションが成功し、他方のトランザクションは失敗するようになります。 失敗したトランザクションは明示的または暗黙的に再送信して、トランザクションを再試行する必要があります。 いずれの場合も、アプリケーションに変更を加える必要があります。<br /><br /> アプリケーションで 2 つの書き込み操作間の競合が頻繁に発生する場合、オプティミスティック ロックの価値は減少します。 このアプリケーションはインメモリ OLTP に適していません。 ほとんどの OLTP アプリケーションでは、競合がロックのエスカレーションによって引き起こされない限り、書き込みの競合はありません。|  
  
## <a name="see-also"></a>参照  
 [インメモリ OLTP &#40;インメモリ最適化&#41;](in-memory-oltp-in-memory-optimization.md)  
  
  
