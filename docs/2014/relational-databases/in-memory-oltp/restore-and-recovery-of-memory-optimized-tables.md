---
title: メモリ最適化テーブルの復元と復旧 | Microsoft Docs
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: 294975b7-e7d1-491b-b66a-fdb1100d2acc
author: CarlRabeler
ms.author: carlrab
manager: craigg
ms.openlocfilehash: 9560249e07cbd360914b5dab21eb68dc8e7f013f
ms.sourcegitcommit: 3026c22b7fba19059a769ea5f367c4f51efaf286
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/15/2019
ms.locfileid: "62467246"
---
# <a name="restore-and-recovery-of-memory-optimized-tables"></a>メモリ最適化テーブルの復元と復旧
  メモリ最適化テーブルを含むデータベースを回復または復元する基本的なメカニズムは、ディスク ベース テーブルのみを含むデータベースのメカニズムに似ています。 ただし、ディスク ベース テーブルとは異なり、メモリ最適化テーブルは、データベースがユーザー アクセスに使用できるようになる前にメモリに読み込まれる必要があります。 データベース復旧の新しい手順が追加されます。 データベース復旧の手順は次のように変更されます:  
  
 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] が再起動すると、各データベースは次の 3 つのフェーズで構成される復旧フェーズを経由します:  
  
1.  分析フェーズ。 このフェーズでは、コミットされたトランザクションとコミットされていないトランザクションを検出するために、アクティブなトランザクション ログにパスが行われます。 インメモリ OLTP エンジンは読み込むチェックポイントを識別し、システム テーブルのログ エントリを再度読み込みます。 また、ファイル割り当てログ レコードの一部を処理します。  
  
2.  再実行フェーズ。 このフェーズは、ディスク ベース テーブルおよびメモリ最適化テーブルで同時に実行されます。  
  
     ディスク ベース テーブルの場合、データベースが現在の状態に移動され、コミットされていないトランザクションに使用されたロックを取得します。  
  
     メモリ最適化テーブルの場合、データ ファイルとデルタ ファイルのペアからのデータがメモリに読み込まれ、次に、持続性を備えた最後のチェックポイントに基づいてアクティブなトランザクション ログを含むデータが更新されます。  
  
     上のディスク ベース テーブルおよびメモリ最適化テーブルでの操作が完了すると、データベースにアクセスできます。  
  
3.  元に戻すフェーズ。 このフェーズでは、コミットされていないトランザクションはロールバックされます。  
  
 メモリ最適化テーブルをメモリに読み込むと、目標復旧時間 (RTO) のパフォーマンスに影響する可能性があります。 データ ファイルおよびデルタ ファイルからメモリ最適化データを読み込む時間を短縮するために、インメモリ OLTP エンジンは次のように並行してデータ ファイルおよびデルタ ファイルを読み込みます。  
  
-   デルタ マップ フィルターの作成。 デルタ ファイル ストアは、削除された行を参照します。 コンテナーごとに 1 行のスレッドがデルタ ファイルを読み取り、デルタ マップ フィルターを作成します。 (メモリ最適化データ ファイル グループには、1 つ以上のコンテナーを保持できます。)  
  
-   データ ファイルのストリーミング。  デルタマップ フィルターが作成されると、データ ファイルは論理 CPU と同数のスレッドを使用して読み込まれます。 データ ファイルを読み込む各スレッドはデータ行を読み込み、関連付けられたデルタ マップを確認し、この行が削除済みとしてマークされていない場合は行の挿入のみを行います。 復旧のこの部分は、以下で説明するように CPU バインドとなる場合があります。  
  
 ![メモリ最適化テーブル。](../../database-engine/media/memory-optimized-tables.gif "メモリ最適化テーブル。")  
  
 通常、メモリ最適化テーブルは I/O の速度でメモリに読み込むことができますが、データ行をメモリに読み込むときは時間がかかる場合があります。 特定の場合を次に示します:  
  
-   ハッシュ インデックスのバケット数が少ない場合は、過剰な競合が発生してデータ行の挿入に時間がかかる可能性があります。 通常、これは、特に復旧の最後にかけて、常に高い CPU 使用率において発生します。 ハッシュ インデックスを正しく構成していれば、復旧時間に影響することはありません。  
  
-   作成時にバケット数がサイズ調整されるハッシュ インデックスとは異なり、1 つ以上の非クラスター化インデックスを含む大きなメモリ最適化テーブルは、非クラスター化インデックスが動的に拡張し、結果として CPU の使用率が高くなります。  
  
## <a name="restoring-a-database-with-memory-optimized-tables"></a>メモリ最適化テーブルでデータベースを復元します。  
 データベースを復元するのに十分なメモリがサーバーにある場合でも、データベースで必要とされるメモリは既存のリソース プールの一部として見なされます。  データベースが存在する前にリソース プールへのバインドを作成することはできません。そこで、RESTORE WITH NORECOVERY を実行します。  これにより、データベースのディスク イメージが復元され、データベースが作成されますが、データベースがオンラインになっていないため、インメモリ OLTP メモリは使用されません。  
  
 この時点で、リソース プールとデータベースのバインドを作成し、RESTORE WITH RECOVERY を使用して復元されたデータベースをオンラインにできます。  データベースがオンラインに設定される前にバインドが設定されたため、インメモリ OLTP メモリの使用が正しく反映されます。 これには、1 回だけデータベースを復元する必要があります。 最初の RESTORE コマンドは、バックアップ ヘッダーのみを読み取る情報取得コマンドです。最後のコマンドは、復元を実行しない、単に回復をトリガーするコマンドです。  
  
## <a name="see-also"></a>参照  
 [メモリ最適化テーブルのバックアップ、復元、復旧](memory-optimized-tables.md)  
  
  
