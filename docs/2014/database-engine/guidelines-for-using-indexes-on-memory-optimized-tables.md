---
title: メモリ最適化テーブルにインデックスを使用するためのガイドライン |Microsoft Docs
ms.custom: ''
ms.date: 03/08/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
helpviewer_keywords:
- hash indexes
ms.assetid: 16ef63a4-367a-46ac-917d-9eebc81ab29b
author: stevestein
ms.author: sstein
manager: craigg
ms.openlocfilehash: 71d26e3f46034019d51bd69b86686f40eb9ce63e
ms.sourcegitcommit: 3026c22b7fba19059a769ea5f367c4f51efaf286
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/15/2019
ms.locfileid: "62779226"
---
# <a name="guidelines-for-using-indexes-on-memory-optimized-tables"></a>メモリ最適化テーブルでのインデックス使用のガイドライン
  [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] テーブルのデータに効率的にアクセスするためにインデックスを使用します。 適切なインデックスを指定することにより、クエリのパフォーマンスが大幅に向上します。 たとえば、クエリを考えてみます。  
  
```sql  
SELECT c1, c2 FROM t WHERE c1 = 1;  
```  
  
 列 c1 にインデックスがない場合、[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] では、テーブル t 全体をスキャンして、条件 c1=1 を満たす行をフィルター処理する必要があります。 一方、列 c1 にインデックスがある場合、[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] では、値 1 を直接シークして行を取得できます。  
  
 テーブルの 1 個以上の列について、特定の値または値の範囲を持つレコードを検索する場合、[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] ではそれらの列のインデックスを使用することで、対応するレコードを迅速に検索できます。 ディスク ベースのテーブルおよびメモリ最適化テーブルのいずれの場合でも、インデックスの利点が得られます。 ただし、インデックス構造間には、メモリ最適化テーブルを使用する場合に考慮する必要がある一定の相違点があります (メモリ最適化されたテーブルのインデックスは、メモリ最適化インデックスと呼ばれます)。主な違いの一部を次に示します。  
  
-   メモリ最適化インデックスを作成する必要があります[CREATE TABLE &#40;TRANSACT-SQL&#41;](/sql/t-sql/statements/create-table-transact-sql)します。 ディスク ベース インデックスは、`CREATE TABLE` および `CREATE INDEX` を使用して作成できます。  
  
-   メモリ最適化インデックスはメモリにしか存在しません。 インデックス構造はディスクに保存されず、インデックス操作はトランザクション ログに記録されません。 インデックス構造は、CREATE TABLE の実行中およびデータベースの起動中に、メモリ最適化テーブルがメモリ内に作成されるときに作成されます。  
  
-   メモリ最適化インデックスは本質的にいきわたっています。 いきわたっているという意味は、すべての列が実質的にインデックスに含まれて、メモリ最適化テーブルにブックマーク参照は必要ないということです。 主キーへの参照ではなく、メモリ最適化インデックスには、テーブル データ構造内の実際の行を指すメモリ ポインターだけが含まれています。  
  
-   断片化と Fillfactor は、メモリ最適化インデックスには適用されません。 ディスク ベース インデックスでは、断片化は、乱れた順序でディスクに書き込まれる B ツリーのページを示します。 メモリ最適化インデックスは、ディスクに対して書き込まれることも読み取られることもありません。 ディスク ベースの B ツリー インデックスの Fillfactor は、物理ページ構造が実際のデータでいっぱいになる度合いを示します。 メモリ最適化インデックス構造には、固定サイズのページはありません。  
  
 メモリ最適化インデックスには、次の 2 種類があります。  
  
-   ポイント参照用に作成された非クラスター化ハッシュ インデックス。 ハッシュ インデックスの詳細については、次を参照してください。[ハッシュ インデックス](hash-indexes.md)します。  
  
-   範囲スキャンと並べ替えられたスキャン用に作成された非クラスター化インデックス。  
  
 ハッシュ インデックスの場合は、インメモリ ハッシュ テーブルを通じてデータにアクセスします。 ハッシュ インデックスにはページはなく、常に固定サイズです。 ただし、ハッシュ インデックスは、限定的な使用されていない空間が生じることになる空のハッシュ バケットを伴うことがあります。 ハッシュ インデックスを使用するクエリから返された値の並べ替えは行われません。 ハッシュ インデックスは、等値述語に対するインデックス シーク用に最適化されており、フル インデックス スキャンをサポートします。  
  
 (ハッシュ インデックスではない) 非クラスター化インデックスでは、ハッシュ インデックスでサポートされるすべての操作に加えて、"より大きい" や "より小さい" などの不等値述語に対するシーク操作、および並べ替え順がサポートされています。 行は、インデックスの作成時に指定した順序に従って取得できます。 インデックスの並べ替え順が特定のクエリに必要な並べ替え順と一致する場合 (たとえば、インデックス キーが ORDER BY 句と一致する場合)、クエリの実行の一環として行を並べ替える必要はありません。 メモリ最適化された非クラスター化インデックスは 1 方向です。つまり、インデックスの並べ替え順の逆となる並べ替え順で行を取得することはサポートされていません。 たとえば、指定されたインデックスが (c1 ASC) の場合、逆順、つまり (c1 DESC) でインデックスをスキャンすることはできません。  
  
 各インデックスはメモリを消費します。 ハッシュ インデックスは、バケット数の関数である固定量のメモリを消費します。 非クラスター化インデックスの場合、メモリ消費量はインデックス キー列の行数とサイズによって決まり、ワークロードによってはオーバーヘッドが増加することがあります。 メモリ最適化インデックス用のメモリは、メモリ最適化テーブルに行を格納するために使用されるメモリとは別であり、これに加えて必要になります。  
  
 重複するキーの値によって、同じハッシュ バケットが常に共有されます。 重複するキーの値がハッシュ インデックスに多数含まれている場合、ハッシュ チェーンが長くなってパフォーマンスが低下します。 どのハッシュ インデックスでも発生するハッシュの競合により、このシナリオではパフォーマンスはさらに低下します。 そのため、一意のインデックス キーの数が、少なくとも 100 回より小さい場合、行の数を減らせるハッシュの競合のリスク、バケット数を大きくする (一意のインデックス キーの数を時刻には少なくとも 8[決定、ハッシュ インデックスのバケット数の正しい](../../2014/database-engine/determining-the-correct-bucket-count-for-hash-indexes.md)詳細については) または非クラスター化インデックスを使用して完全ハッシュの競合を排除することができます。  
  
## <a name="determining-which-indexes-to-use-for-a-memory-optimized-table"></a>メモリ最適化テーブルに使用するインデックスの決定  
 それぞれのメモリ最適化テーブルには、1 つ以上のインデックスが必要です。 それぞれの PRIMARY KEY 制約では、暗黙的にインデックスを作成します。 したがって、テーブルに主キーがある場合は、インデックスがあります。 主キーは、持続性のあるメモリ最適化テーブルに必須です。  
  
 メモリ最適化テーブルを照会する際に、述語句に等値述語のみが含まれている場合は、ハッシュ インデックスのパフォーマンスが高くなります。 述語はハッシュ インデックス キーのすべての列を含める必要があります。 ハッシュ インデックスは、非等値述語が指定されているとスキャンに戻ります。  
  
 メモリ最適化テーブルの列は、ハッシュ インデックスと非クラスター化インデックスの両方に含めることができます。  
  
 非等値述語でメモリ最適化テーブルを照会する場合は、非クラスター化ハッシュ インデックスより非クラスター化インデックスのパフォーマンスが高くなります。  
  
 ハッシュ インデックスでは、インデックスに対してシークを実行するための (ハッシュ用の) キーが必要です。 インデックス キーが 2 列で構成される場合に、最初の列しか指定されないと、[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] でハッシュ用とするキーが不完全になります。 この場合は、インデックス スキャン クエリ プランが作成されます。 インデックスを設定する列は、使用状況によって決定されます。  
  
 非クラスター化インデックスの列の値が、多数の行で同じである (インデックス キー列に多数の重複値がある) 場合は、更新、挿入、および削除に関してパフォーマンスが低下します。  このような場合にパフォーマンスを改善する方法の 1 つは、非クラスター化インデックスに列を追加することです。  
  
### <a name="operations-on-memory-optimized-and-disk-based-indexes"></a>メモリ最適化インデックスおよびディスク ベース インデックスに対する操作  
  
|操作|メモリ最適化された非クラスター化ハッシュ インデックス|メモリ最適化された非クラスター化インデックス|ディスク ベース インデックス|  
|---------------|-------------------------------------------------|------------------------------------------|-----------------------|  
|インデックス スキャン、すべてのテーブルの行を取得する。|はい|[はい]|はい|  
|等値述語 (=) に対するインデックス シーク。|はい<br /><br /> (フル キーが必要)|はい <sup>1</sup>|はい|  
|非等値述語に対するインデックス シーク (>、<、 \<=、> =, BETWEEN)。|不可 (インデックス スキャンの結果)|はい <sup>1</sup>|はい|  
|インデックス定義に一致する並べ替え順序で行を取得する。|いいえ|はい|はい|  
|インデックス定義の逆の並べ替え順序で行を取得する。|いいえ|いいえ|はい|  
  
 この表で、可はインデックスによって要求を十分に満たすことができることを意味し、不可は要求を満たすためにインデックスを適切に使用できないことを意味します。  
  
 <sup>1</sup>非クラスター化メモリ最適化インデックスのフル キーはないインデックス シークの実行に必要です。 ただし、インデックスのキー列の順序が指定されている場合、列の値の前に見つからない列があると、スキャンが発生します。  
  
## <a name="index-count"></a>インデックスの数  
 メモリ最適化テーブルには最大 8 個のインデックスを設定できます。これには、主キーで作成されるインデックスを含みます。  
  
 メモリ最適化テーブルに作成されるインデックスの数については、次のことを考慮してください。  
  
-   テーブルの作成時に、必要なインデックスを指定します。 テーブルの作成後は、メモリ最適化テーブルのインデックスを作成できません。 メモリ最適化テーブルにインデックスを追加する場合は、そのテーブルを削除してから再作成します。  
  
-   ほとんど使用しないインデックスは作成しないでください。  
  
     ガベージ コレクションは、テーブルのすべてのインデックスを頻繁に使用する場合に最適です。 ほとんど使用しないインデックスがある場合、ガベージ コレクション システムは古い行バージョンに対して適切に機能しないことがあります。  
  
## <a name="creating-a-memory-optimized-index-code-samples"></a>メモリ最適化インデックスの作成:コード サンプル  
 列レベルのハッシュ インデックス:  
  
```sql  
CREATE TABLE t1   
   (c1 INT NOT NULL INDEX idx HASH WITH (BUCKET_COUNT = 100))   
   WITH (MEMORY_OPTIMIZED = ON, DURABILITY = SCHEMA_ONLY)  
```  
  
 テーブル レベルのハッシュ インデックス:  
  
```sql  
CREATE TABLE t1_1   
   (c1 INT NOT NULL,   
   INDEX IDX HASH (c1) WITH (BUCKET_COUNT = 100))   
   WITH (MEMORY_OPTIMIZED = ON, DURABILITY = SCHEMA_ONLY)  
```  
  
 列レベルの主キーのハッシュ インデックス:  
  
```sql  
CREATE TABLE t2   
   (c1 INT NOT NULL PRIMARY KEY NONCLUSTERED HASH WITH (BUCKET_COUNT = 100))   
   WITH (MEMORY_OPTIMIZED = ON, DURABILITY = SCHEMA_AND_DATA)  
```  
  
 テーブル レベルの主キーのハッシュ インデックス:  
  
```sql  
CREATE TABLE t2_2   
   (c1 INT NOT NULL,   
   PRIMARY KEY NONCLUSTERED HASH (c1) WITH (BUCKET_COUNT = 100))   
   WITH (MEMORY_OPTIMIZED = ON, DURABILITY = SCHEMA_AND_DATA)  
```  
  
 列レベルの非クラスター化インデックス:  
  
```sql  
CREATE TABLE t3   
   (c1 INT NOT NULL INDEX ID)   
   WITH (MEMORY_OPTIMIZED = ON, DURABILITY = SCHEMA_ONLY)  
```  
  
 テーブル レベルの非クラスター化インデックス:  
  
```sql  
CREATE TABLE t3_3   
   (c1 INT NOT NULL,   
   INDEX IDX NONCLUSTERED (c1))   
   WITH (MEMORY_OPTIMIZED = ON, DURABILITY = SCHEMA_ONLY)  
```  
  
 列レベルの主キー非クラスター化インデックス:  
  
```sql  
CREATE TABLE t4   
   (c1 INT NOT NULL PRIMARY KEY NONCLUSTERED)   
   WITH (MEMORY_OPTIMIZED = ON, DURABILITY = SCHEMA_AND_DATA)  
```  
  
 テーブル レベルの主キー非クラスター化インデックス:  
  
```sql  
CREATE TABLE t4_4   
   (c1 INT NOT NULL,   
   PRIMARY KEY NONCLUSTERED (c1))   
   WITH (MEMORY_OPTIMIZED = ON, DURABILITY = SCHEMA_AND_DATA)  
```  
  
 列を定義した後に定義される複数列のインデックス:  
  
```sql  
create table t (  
       a int not null constraint ta primary key nonclustered,  
       b int not null,  
       c int not null,  
       d int not null,  
       index idx_t_b_c_d nonclustered (b, c asc, d desc)  
) with (memory_optimized = on, durability = SCHEMA_AND_DATA)  
go  
```  
  
## <a name="see-also"></a>参照  
 [メモリ最適化テーブルのインデックス](../relational-databases/in-memory-oltp/memory-optimized-tables.md)   
 [ハッシュ インデックスの適切なバケット数を決定します。](../../2014/database-engine/determining-the-correct-bucket-count-for-hash-indexes.md)   
 [ハッシュ インデックス](hash-indexes.md)  
  
  
