---
title: SQL Server でのスナップショット分離
description: トランザクションアプリケーションでのブロックを減らすために設計された、行のバージョン管理メカニズムである、スナップショット分離のサポートについて説明します。
ms.date: 08/15/2019
dev_langs:
- csharp
ms.assetid: 43ae5dd3-50f5-43a8-8d01-e37a61664176
ms.prod: sql
ms.prod_service: connectivity
ms.technology: connectivity
ms.topic: conceptual
author: v-kaywon
ms.author: v-kaywon
ms.reviewer: rothja
ms.openlocfilehash: 8ef462246d35694ba9bf38954ca8c58635e44e7f
ms.sourcegitcommit: 9c993112842dfffe7176decd79a885dbb192a927
ms.translationtype: MTE75
ms.contentlocale: ja-JP
ms.lasthandoff: 10/16/2019
ms.locfileid: "72452082"
---
# <a name="snapshot-isolation-in-sql-server"></a>SQL Server でのスナップショット分離

![Download-DownArrow-Circled](../../../ssdt/media/download.png)[ADO.NET をダウンロードする](../../sql-connection-libraries.md#anchor-20-drivers-relational-access)

スナップショット分離では、OLTP アプリケーションの同時実行性が向上します。  
  
## <a name="understanding-snapshot-isolation-and-row-versioning"></a>スナップショット分離と行のバージョン管理について  
スナップショット分離が有効になると、各トランザクションの更新された行のバージョン管理は、**tempdb** に保持されます。 一意のトランザクションシーケンス番号によって各トランザクションが識別されます。これらの一意の番号は、行バージョンごとに記録されます。 トランザクションは、トランザクションのシーケンス番号の前にシーケンス番号を持つ最新の行バージョンで動作します。 トランザクションの開始後に作成された新しい行バージョンは、トランザクションによって無視されます。  
  
"スナップショット" という用語は、トランザクション内のすべてのクエリが、トランザクションの開始時点のデータベースの状態に基づいて、データベースの同じバージョン (スナップショット) を参照するという事実を反映しています。 スナップショットトランザクション内の基になるデータ行またはデータページに対してロックは取得されません。これにより、前の完了していないトランザクションによってブロックされることなく、他のトランザクションを実行できます。 データを変更するトランザクションは、データを読み取るトランザクションをブロックしません。また、データを読み取るトランザクションは、通常、SQL Server の既定の READ COMMITTED 分離レベルで行われるため、データを書き込むトランザクションをブロックしません。 この非ブロッキング動作によって、複雑なトランザクションがデッドロックする可能性も大幅に減少します。  
  
スナップショット分離では、オプティミスティック同時実行制御モデルを使用します。 トランザクションの開始以降に変更されたデータに対する変更をスナップショットトランザクションでコミットしようとすると、トランザクションがロールバックされ、エラーが発生します。 これを回避するには、変更するデータにアクセスする SELECT ステートメントに UPDLOCK ヒントを使用します。 詳細については、SQL Server オンラインブックの「ロックのヒント」を参照してください。  
  
スナップショット分離は、トランザクションで使用する前に、ALLOW_SNAPSHOT_ISOLATION ON データベースオプションを設定することによって有効にする必要があります。 これにより、行バージョンを一時データベース (**tempdb**) 内に保存するためのメカニズムがアクティブになります。 Transact-sql の ALTER DATABASE ステートメントと共に使用する各データベースでスナップショット分離を有効にする必要があります。 この点で、スナップショット分離は、構成を必要としない、READ COMMITTED、REPEATABLE READ、SERIALIZABLE、および READ COMMITTED という従来の分離レベルとは異なります。 次のステートメントでは、スナップショット分離をアクティブ化し、既定の READ COMMITTED 動作を SNAPSHOT に置き換えます。  
  
```sql  
ALTER DATABASE MyDatabase  
SET ALLOW_SNAPSHOT_ISOLATION ON  
  
ALTER DATABASE MyDatabase  
SET READ_COMMITTED_SNAPSHOT ON  
```  
  
READ_COMMITTED_SNAPSHOT ON オプションを設定すると、既定の READ COMMITTED 分離レベルでバージョン管理された行にアクセスできます。 READ_COMMITTED_SNAPSHOT オプションが OFF に設定されている場合は、バージョン管理された行にアクセスするために、各セッションに対して明示的にスナップショット分離レベルを設定する必要があります。  
  
## <a name="managing-concurrency-with-isolation-levels"></a>分離レベルでの同時実行の管理  
Transact-sql ステートメントが実行される分離レベルによって、ロックおよび行のバージョン管理の動作が決まります。 分離レベルには接続全体のスコープがあり、SET TRANSACTION 分離レベルステートメントを使用して接続を設定すると、接続が閉じられるか別の分離レベルが設定されるまで、有効なままになります。 接続が閉じられ、プールに返されると、最後の SET TRANSACTION 分離レベルステートメントからの分離レベルが保持されます。 プールされた接続を再利用する後続の接続では、接続がプールされたときに有効であった分離レベルが使用されます。  
  
接続内で実行される個々のクエリには、1つのステートメントまたはトランザクションの分離を変更するロックヒントを含めることができますが、接続の分離レベルには影響しません。 ストアドプロシージャまたは関数で設定された分離レベルまたはロックヒントでは、それらを呼び出す接続の分離レベルは変更されず、ストアドプロシージャまたは関数呼び出しの間だけ有効になります。  
  
以前のバージョンの SQL Server では、SQL-92 標準で定義されている4つの分離レベルがサポートされていました。  
  
- READ 未確定は、他のトランザクションによって設定されたロックを無視するため、最も制限の緩い分離レベルです。 READ committed で実行中のトランザクションは、他のトランザクションによってまだコミットされていない変更されたデータ値を読み取ることができます。これらは "ダーティ" 読み取りと呼ばれます。  
  
- READ COMMITTED は、SQL Server の既定の分離レベルです。 これにより、変更されても他のトランザクションによってコミットされていないデータ値をステートメントで読み取ることができないように指定することで、ダーティリードを防止できます。 その他のトランザクションでは、現在のトランザクション内の個々のステートメントの実行間でデータを変更、挿入、または削除できます。その結果、反復不可能な読み取りや "ファントム" データが発生します。  
  
- REPEATABLE READ は、READ COMMITTED よりも制限の厳しい分離レベルです。 READ COMMITTED を含み、現在のトランザクションがコミットされるまで、現在のトランザクションによって読み取られたデータを他のトランザクションが変更または削除できないように指定します。 読み取りデータに対する共有ロックは、各ステートメントの最後に解放されるのではなく、トランザクションの実行中保持されるため、同時実行は READ COMMITTED よりも低くなります。  
  
- キー範囲全体がロックされ、トランザクションが完了するまでその状態が保持されるので、SERIALIZABLE は最も制限の厳しい分離レベルといえます。 反復可能な読み取りを含み、トランザクションが完了するまで、他のトランザクションによって読み取られた範囲に新しい行を挿入できないという制限を追加します。  
  
詳細については、「[トランザクションのロックおよび行のバージョン管理ガイド](../../../relational-databases/sql-server-transaction-locking-and-row-versioning-guide.md)」を参照してください。  
  
### <a name="snapshot-isolation-level-extensions"></a>スナップショット分離レベルの拡張機能  
SQL Server では、SNAPSHOT 分離レベルの導入および READ COMMITTED の追加実装と共に、SQL-92 分離レベルの機能を強化しています。 READ_COMMITTED_SNAPSHOT 分離レベルは、すべてのトランザクションの READ COMMITTED を自動的に置き換えることができます。  
  
- スナップショット分離では、トランザクション内で読み取られるデータに、他の同時実行トランザクションによる変更が反映されないように指定します。 トランザクションでは、トランザクションの開始時に存在していたデータ行のバージョンが使用されます。 データが読み込まれるときにロックが設定されていないため、スナップショットトランザクションでは、他のトランザクションによるデータの書き込みがブロックされることはありません。 トランザクションでデータが書き込まれている間も、SNAPSHOT トランザクションではデータを読み取ることができます。 使用するには、ALLOW_SNAPSHOT_ISOLATION データベースオプションを設定して、スナップショット分離を有効にする必要があります。  
  
- READ_COMMITTED_SNAPSHOT データベースオプションは、データベースでスナップショット分離が有効になっている場合に、既定の READ COMMITTED 分離レベルの動作を決定します。 READ_COMMITTED_SNAPSHOT を明示的に指定しない場合は、すべての暗黙のトランザクションに READ COMMITTED が適用されます。 これにより、READ_COMMITTED_SNAPSHOT を OFF (既定値) に設定した場合と同じ動作が生成されます。 READ_COMMITTED_SNAPSHOT OFF が有効になっている場合、データベースエンジンは共有ロックを使用して既定の分離レベルを適用します。 READ_COMMITTED_SNAPSHOT データベースオプションを ON に設定した場合、データベースエンジンは、データを保護するためにロックを使用するのではなく、行のバージョン管理とスナップショット分離を既定値として使用します。  
  
## <a name="how-snapshot-isolation-and-row-versioning-work"></a>スナップショット分離と行のバージョン管理のしくみ  
SNAPSHOT 分離レベルが有効になっている場合、行が更新されるたびに、SQL Server データベース エンジンは **tempdb** 内の元の行のコピーを保存し、行にトランザクション シーケンス番号を追加します。 発生するイベントのシーケンスを次に示します。  
  
1. 新しいトランザクションが開始され、トランザクションシーケンス番号が割り当てられます。  
  
2. データベース エンジンは、トランザクション内の行を読み取り、トランザクション シーケンス番号より小さくて、トランザクション シーケンス番号に最も近いシーケンス番号の行バージョンを、**tempdb** から取得します。  
  
3. データベースエンジンは、スナップショットトランザクションが開始されたときにアクティブになっているコミットされていないトランザクションのトランザクションシーケンス番号の一覧に、トランザクションシーケンス番号が含まれていないかどうかを確認します。  
  
4. トランザクションは、トランザクションの開始時点で最新だった **tempdb** から、行のバージョンを読み取ります。 トランザクションの開始後に挿入された新しい行は、これらのシーケンス番号の値がトランザクションシーケンス番号の値よりも大きいため、表示されません。  
  
5. 現在のトランザクションは、トランザクションの開始後に削除された行を確認します。この理由は、トランザクション シーケンス番号より小さいシーケンス番号の値を持つ行バージョンが **tempdb** 内に存在する可能性があるためです。  
  
スナップショット分離の実質的な影響として、トランザクションの開始時に存在していたすべてのデータが、基になるテーブルに対するロックの適用や配置を行わずに表示されます。 これにより、競合が発生した場合にパフォーマンスが向上する可能性があります。  
  
スナップショットトランザクションは常にオプティミスティック同時実行制御を使用し、他のトランザクションによって行が更新されないようにするロックを源泉徴収します。 スナップショットトランザクションが、トランザクションの開始後に変更された行に対して更新をコミットしようとすると、トランザクションがロールバックされ、エラーが発生します。  
  
## <a name="working-with-snapshot-isolation-in-adonet"></a>ADO.NET でスナップショット分離を使用する  
スナップショット分離は、<xref:Microsoft.Data.SqlClient.SqlTransaction> クラスによって ADO.NET でサポートされています。 データベースでスナップショット分離が有効になっているが、READ_COMMITTED_SNAPSHOT ON に構成されていない場合、<xref:Microsoft.Data.SqlClient.SqlConnection.BeginTransaction%2A> メソッドの呼び出し時に **IsolationLevel.Snapshot** 列挙値を使って、<xref:Microsoft.Data.SqlClient.SqlTransaction> を開始する必要があります。 このコード片は、接続が open <xref:Microsoft.Data.SqlClient.SqlConnection> オブジェクトであることを前提としています。  
  
```csharp  
SqlTransaction sqlTran =   
  connection.BeginTransaction(IsolationLevel.Snapshot);  
```  
  
### <a name="example"></a>例  
次の例では、ロックされたデータにアクセスすることによって、さまざまな分離レベルがどのように動作するかを示します。これは、実稼働コードでの使用を目的としていません。  
  
このコードは、SQL Server の **AdventureWorks** サンプル データベースに接続し、**TestSnapshot** というテーブルを作成し、1 行のデータを挿入します。 このコードでは、ALTER DATABASE Transact-sql ステートメントを使用してデータベースのスナップショット分離を有効にしますが、READ_COMMITTED_SNAPSHOT オプションは設定せず、既定の READ COMMITTED 分離レベルの動作が有効なままにします。 このコードは、次のアクションを実行します。  
  
1. SqlTransaction1 が開始されますが、完全ではありません。これは、SERIALIZABLE 分離レベルを使用して更新トランザクションを開始します。 これには、テーブルをロックする効果があります。  
  
2. 2 つ目の接続を開き、SNAPSHOT 分離レベルを使って 2 つ目のトランザクションを開始し、**TestSnapshot** テーブル内のデータを読み取ります。 スナップショット分離が有効になっているため、このトランザクションでは、sqlTransaction1 が開始される前に存在していたデータを読み取ることができます。  
  
3. 3番目の接続を開き、READ COMMITTED 分離レベルを使用してトランザクションを開始し、テーブル内のデータの読み取りを試みます。 この場合、コードはデータを読み取れません。コードは最初のトランザクション内のテーブルに置かれたロックを超えて読み取りを行うことができず、タイムアウトになるためです。REPEATABLE READ 分離レベルと SERIALIZABLE 分離レベルが使用されている場合は、これらの分離レベルも、最初のトランザクション内に置かれたロックを超えて読み取りを行うことができないため、同じ結果になります。  
  
4. 4番目の接続を開き、READ 未確定分離レベルを使用してトランザクションを開始します。これにより、sqlTransaction1 のコミットされていない値のダーティリードが実行されます。 最初のトランザクションがコミットされていない場合、この値はデータベースに実際には存在しない可能性があります。  
  
5. **TestSnapshot** テーブルを削除し、**AdventureWorks** データベースのスナップショット分離をオフにすることにより、最初のトランザクションをロールバックおよびクリーンアップします。  
  
> [!NOTE]
>  次の例では、接続プールが無効になっているのと同じ接続文字列を使用します。 接続がプールされている場合、その分離レベルをリセットしても、サーバーの分離レベルはリセットされません。 その結果、同じプールされた内部接続を使用する後続の接続は、プールされた接続の分離レベルで開始されます。 接続プールを無効にする代わりに、各接続の分離レベルを明示的に設定することもできます。  
  
[!code-csharp[DataWorks Isolation_Snapshot.Demo#1](~/../sqlclient/doc/samples/Isolation_Snapshot.cs#1)]
  
### <a name="example"></a>例  
次の例は、データが変更されているときのスナップショット分離の動作を示しています。 このコードで次のアクションが実行されます。  
  
1. **AdventureWorks** サンプル データベースに接続し、SNAPSHOT 分離を有効にします。  
  
2. **TestSnapshotUpdate** という名前のテーブルを作成し、3 行のサンプル データを挿入します。  
  
3. スナップショット分離を使用して sqlTransaction1 を開始しますが、完了しません。 トランザクションでは、3行のデータが選択されます。  
  
4. 2 つ目の **SqlConnection** を **AdventureWorks** に対して作成し、sqlTransaction1 内で選択された行のうち 1 行の値を更新する READ COMMITTED 分離レベルを使用して、2 つ目のトランザクションを作成します。  
  
5. SqlTransaction2 をコミットします。  
  
6. SqlTransaction1 に戻り、sqlTransaction1 が既にコミットされているのと同じ行を更新しようとします。 エラー3960が発生し、sqlTransaction1 が自動的にロールバックされます。 **SqlException.Number** と **SqlException.Message** がコンソール ウィンドウに表示されます。  
  
7. クリーンアップ コードを実行して **AdventureWorks** 内のスナップショット分離をオフにし、**TestSnapshotUpdate** テーブルを削除します。  
  
    [!code-csharp[DataWorks Isolation_Snapshot1#1](~/../sqlclient/doc/samples/Isolation_Snapshot1.cs#1)]
  
### <a name="using-lock-hints-with-snapshot-isolation"></a>スナップショット分離でのロックヒントの使用  
前の例では、最初のトランザクションがデータを選択し、2番目のトランザクションによってデータが更新されてから、最初のトランザクションが完了するまでの間、最初のトランザクションが同じ行を更新しようとしたときに更新の競合が発生します。 トランザクションの開始時にロックヒントを指定することで、実行時間の長いスナップショットトランザクションで更新の競合が発生する可能性を減らすことができます。 次の SELECT ステートメントでは、UPDLOCK ヒントを使用して、選択した行をロックします。  
  
```sql  
SELECT * FROM TestSnapshotUpdate WITH (UPDLOCK)   
  WHERE PriKey BETWEEN 1 AND 3  
```  
  
UPDLOCK lock ヒントを使用すると、最初のトランザクションが完了する前に行を更新しようとするすべての行がブロックされます。 これにより、選択した行がトランザクションの後で更新されるときに競合が生じないことが保証されます。 SQL Server オンラインブックの「ロックのヒント」を参照してください。  
  
アプリケーションに多数の競合がある場合は、スナップショット分離が最適な選択肢ではない可能性があります。 ヒントは、本当に必要な場合にのみ使用してください。 アプリケーションは、その操作のロックヒントに常に依存するように設計しないでください。  
  
## <a name="next-steps"></a>次の手順
- [SQL Server と ADO.NET](index.md)
- [トランザクションのロックおよび行のバージョン管理ガイド](../../../relational-databases/sql-server-transaction-locking-and-row-versioning-guide.md)
