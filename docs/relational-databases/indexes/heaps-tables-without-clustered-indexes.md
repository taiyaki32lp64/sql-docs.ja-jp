---
title: ヒープ (クラスター化インデックスなしのテーブル) | Microsoft Docs
ms.custom: ''
ms.date: 11/01/2016
ms.prod: sql
ms.prod_service: table-view-index, sql-database
ms.reviewer: ''
ms.technology: table-view-index
ms.topic: conceptual
helpviewer_keywords:
- heaps
ms.assetid: df5c4dfb-d372-4d0f-859a-a2d2533ee0d7
author: MikeRayMSFT
ms.author: mikeray
monikerRange: =azuresqldb-current||>=sql-server-2016||=sqlallproducts-allversions||>=sql-server-linux-2017||=azuresqldb-mi-current
ms.openlocfilehash: 5234820dbf88067aad2ff76b0bd373c7f70cb3e1
ms.sourcegitcommit: b2464064c0566590e486a3aafae6d67ce2645cef
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/15/2019
ms.locfileid: "67909784"
---
# <a name="heaps-tables-without-clustered-indexes"></a>ヒープ (クラスター化インデックスなしのテーブル)
[!INCLUDE[appliesto-ss-asdb-xxxx-xxx-md](../../includes/appliesto-ss-asdb-xxxx-xxx-md.md)]

  ヒープとはクラスター化インデックスを使用しないテーブルのことです。 1 つまたは複数の非クラスター化インデックスを、ヒープとして格納されているテーブルに作成することができます。 ヒープには、順序を指定せずにデータが格納されます。 通常、最初にデータが格納される順序はテーブルに行が挿入された順序と同じですが、 [!INCLUDE[ssDE](../../includes/ssde-md.md)] では行を効率的に格納できるようにヒープ内でデータが移動される場合があるため、データの順序は予測できません。 ヒープから返される行の順序を保証するには、 **ORDER BY** 句を使用する必要があります。 テーブルにクラスター化インデックスを作成し、テーブルがヒープにならないようにすることで、行が格納される順序を指定することができます。  
  
> [!NOTE]  
>  クラスター化インデックスを作成する代わりにテーブルをヒープのままにしておくとよい場合もありますが、ヒープを効果的に使用するには高度なスキルが必要です。 テーブルをヒープのままにしておく妥当な理由がない限り、ほとんどのテーブルには、慎重に選択されたクラスター化インデックスが必要です。  
  
## <a name="when-to-use-a-heap"></a>ヒープを使用する場合  
 非クラスター化インデックスのないヒープ テーブルの場合、行を検索するには (テーブル スキャンで) テーブル全体を調べる必要があります。 企業の 12 の支社の一覧など、テーブルが小さい場合にはこの方法で対応できます。  
  
 テーブルがヒープとして格納されている場合、各行の識別には、ファイル番号、データ ページ番号、およびページのスロットで構成された行識別子 (RID) が使用されます。 行識別子 (ROWID) には、小さく効率的な構造が使用されています。 データ設計者は、データが常に非クラスター化インデックスを通じてアクセスされ、RID がクラスター化インデックス キーより小さい場合に、ヒープを使用することもあります。  
  
## <a name="when-not-to-use-a-heap"></a>ヒープを使用しない場合  
 データが、並べ替えた順序で頻繁に取得される場合は、ヒープを使用しないでください。 並べ替え用の列にクラスター化インデックスが存在すると、並べ替え操作が実行されない場合があります。  
  
 データが頻繁にグループ化される場合は、ヒープを使用しないでください。 データの並べ替えはグループ化よりも前に行う必要がありますが、並べ替え用の列にクラスター化インデックスが存在すると、並べ替え操作が実行されない場合があります。  
  
 広範囲のデータがテーブルから頻繁に照会される場合は、ヒープを使用しないでください。  範囲列にクラスター化インデックスが存在すると、ヒープ全体の並べ替えが実行されなくなります。  
  
 非クラスター化インデックスが存在せず、テーブルが大きい場合は、ヒープを使用しないでください。 ヒープでは、特定の行を探すためにヒープのすべての行を読み取る必要があります。  
  
## <a name="managing-heaps"></a>ヒープの管理  
 ヒープを作成するには、クラスター化インデックスのないテーブルを作成します。 既にテーブルにクラスター化インデックスが含まれている場合は、クラスター化インデックスを削除して、テーブルをヒープに戻します。  
  
 ヒープを削除するには、ヒープにクラスター化インデックスを作成します。  
  
 使用されていない領域を再利用できるようにヒープを再構築するには、ヒープにクラスター化インデックスを作成してから、そのクラスター化インデックスを削除します。  
  
> [!WARNING]  
>  クラスター化インデックスを作成または削除するには、テーブル全体を再作成する必要があります。 テーブルに非クラスター化インデックスがある場合は、クラスター化インデックスが変更されるたびに、すべての非クラスター化インデックスを再作成する必要があります。 このため、ヒープからクラスター化インデックス構造への変更、またはその逆の変更には時間がかかり、tempdb でデータの順序を並べ替えるためのディスク領域が必要になります。  

## <a name="heap-structures"></a>ヒープ構造


ヒープとはクラスター化インデックスを使用しないテーブルのことです。 ヒープは、 [sys.partitions](../../relational-databases/system-catalog-views/sys-partitions-transact-sql.md)に 1 行を持っており、ヒープに使われる各パーティションは `index_id = 0` になります。 既定では、ヒープのパーティションは 1 つです。 ヒープにパーティションが複数ある場合、各パーティションは、そのパーティションのデータを保持するヒープ構造になります。 たとえば、ヒープに 4 つのパーティションがある場合、4 つのヒープを持つ構造になります。この場合、パーティションごとに 1 つのヒープがあります。

ヒープ内のデータ型によっては、各ヒープ構造に 1 つ以上のアロケーション ユニットが含まれ、そこに特定のパーティションのデータが格納され、管理されます。 各ヒープには、パーティションごとに、少なくとも 1 つの `IN_ROW_DATA` アロケーション ユニットがあります。 また、ヒープにラージ オブジェクト (LOB) 列が含まれている場合は、パーティションごとに 1 つの `LOB_DATA` アロケーション ユニットもあります。 さらに、行サイズの上限である 8,060 バイトを超える可変長列が含まれている場合は、パーティションごとに 1 つの `ROW_OVERFLOW_DATA` アロケーション ユニットがあります。

`first_iam_page` システム ビュー内の列 `sys.system_internals_allocation_units` は、特定のパーティション内のヒープに割り当てられた領域を管理する IAM ページのチェーン内の最初の IAM ページをポイントします。 SQL Server は、IAM ページを使用してヒープ内を移動します。 データ ページとその中にある行は特定の順序になっておらず、リンクもされていません。 データ ページ間の論理接続は、IAM ページ内に記録されている情報だけです。

> [!IMPORTANT]  
> `sys.system_internals_allocation_units` システム ビューは Microsoft SQL Server の内部使用専用に予約されています。 将来の互換性は保証されません。
 
IAM をスキャンしてヒープのページを保持しているエクステントを見つけることによって、ヒープのテーブル スキャンまたはシリアル読み取りが行われます。 IAM ではエクステントがデータ ファイルに入っている順序で表されています。したがって、シリアル ヒープ スキャンでは各ファイルが順に読み取られて進行します。 スキャン シーケンスの設定に IAM ページを使用すると、ヒープの行が挿入順どおりに戻されるとは限らないことになります。

次の図に、IAM ページを使用して単一パーティションのヒープ内のデータ行が SQL Server データベース エンジンで取得されるしくみを示します。 

![iam_heap](../../relational-databases/indexes/media/iam-heap.gif)

  
## <a name="related-content"></a>関連コンテンツ  
[CREATE INDEX &#40;Transact-SQL&#41;](../../t-sql/statements/create-index-transact-sql.md)     
[DROP INDEX &#40;Transact-SQL&#41;](../../t-sql/statements/drop-index-transact-sql.md)     
[クラスター化インデックスと非クラスター化インデックスの概念](../../relational-databases/indexes/clustered-and-nonclustered-indexes-described.md)     
  
  
