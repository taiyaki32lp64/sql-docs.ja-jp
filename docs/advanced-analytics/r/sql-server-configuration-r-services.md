---
title: R で使用するための構成
description: この記事では、SQL Server R Services を実行するために使用するコンピューターのハードウェアおよびネットワーク構成に関するガイダンスを提供します。
ms.prod: sql
ms.technology: machine-learning
ms.date: 03/29/2019
ms.topic: conceptual
author: dphansen
ms.author: davidph
ms.custom: seo-lt-2019
monikerRange: '>=sql-server-2016||>=sql-server-linux-ver15||=sqlallproducts-allversions'
ms.openlocfilehash: 7d18661fadb12167fd0a443758cced1188401750
ms.sourcegitcommit: 09ccd103bcad7312ef7c2471d50efd85615b59e8
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/07/2019
ms.locfileid: "73727340"
---
# <a name="sql-server-configuration-for-use-with-r"></a>R で使用するための SQL Server の構成
[!INCLUDE[appliesto-ss-xxxx-xxxx-xxx-md](../../includes/appliesto-ss-xxxx-xxxx-xxx-md.md)]

これは、2 つのケース スタディに基づいて R Services のパフォーマンスの最適化について説明するシリーズの 2 番目の記事です。  この記事では、SQL Server R Services を実行するために使用するコンピューターのハードウェアおよびネットワーク構成に関するガイダンスを提供します。 また、ソリューションで使用される SQL Server インスタンス、データベース、またはテーブルを構成する方法についても説明します。 SQL Server で NUMA を使用すると、ハードウェアとデータベースの最適化の間の区別が曖昧になるので、3 番目のセクションでは、CPU のアフィニタイズとリソース ガバナンスの詳細について説明します。

> [!TIP]
> SQL Server を初めて使用する場合は、「SQL Server のパフォーマンス チューニング ガイド」も確認することを強くお勧めします。[パフォーマンスの監視とチューニング](https://docs.microsoft.com/sql/relational-databases/performance/monitor-and-tune-for-performance)

## <a name="hardware-optimization"></a>ハードウェアの最適化

外部スクリプトを実行するためのリソースがあることを確認するには、サーバー コンピューターの最適化が重要です。 リソースが制限されている場合は、次のような現象が発生する可能性があります。

- 他のデータベース操作を優先するために、ジョブの実行が延期または取り消されます。
- "クォータを超過しました" というエラーが発生したため、R スクリプトが完了せずに終了します。
- R メモリに読み込まれたデータが切り捨てられ、不完全な結果になります。

### <a name="memory"></a>[メモリ]

コンピューター上で利用できるメモリの量は、高度な分析アルゴリズムのパフォーマンスに大きな影響を与える場合があります。 メモリが不足していると、SQL の計算コンテキストを使用している場合に、並列処理のレベルが低下することがあります。 また、処理可能なチャンク サイズ (読み取り操作あたりの行数) や、サポートできる同時セッション数にも影響する可能性があります。

最小でも、32 GB のメモリを使用することを強くお勧めします。 32 GB を超えるメモリを搭載した場合は、読み取り操作あたりの行数を増やすように SQL データ ソースを構成して、パフォーマンスを高めることができます。

また、インスタンスによって使用されるメモリを管理することもできます。 既定では、メモリが割り当てられている場合、SQL Server は外部スクリプト プロセスより優先されます。 R Services の既定のインストールでは、使用可能なメモリの 20% のみが R に割り当てられます。

通常、これはデータ サイエンス タスクには不十分ですが、SQL Server のメモリが不足しないようにする必要があります。 状況によって最適な構成が異なることを理解しながら、データベース エンジン、関連サービス、外部スクリプトの間のメモリ割り当てを実験して微調整する必要があります。

再開照合モデルの場合、外部スクリプトの使用率が非常に高く、他のデータベース エンジン サービスは実行されていませんでした。そのため、外部スクリプトに割り当てられるリソースは 70% に増加し、これは、スクリプトのパフォーマンスに最適な構成でした。

### <a name="power-options"></a>電源オプション

Windows オペレーティング システムでは、**高パフォーマンス**電源オプションを使用してください。 その他の電源設定を使用すると、SQL Server の使用時にパフォーマンスが低下したり、パフォーマンスの一貫性が損なわれます。

### <a name="disk-io"></a>ディスク IO

R Services を使用したトレーニング ジョブや予測ジョブは、本質的に IO バインドであり、データベースが格納されているディスクの速度に依存します。 ソリッド ステート ドライブ (SSD) などの高速なドライブを使用したほうが、目的にかなう可能性があります。

ディスク IO は、ディスクにアクセスする他のアプリケーションによっても影響を受けます (たとえば、データベースに対して読み取り操作を行う他のクライアントなど)。 またディスク IO のパフォーマンスは、使用されているファイル システムの設定によっても影響を受けることがあります (ファイル システムによって使用されるブロック サイズなど)。

複数のドライブを利用できる場合は、SQL Server とは別のドライブにデータベースを保存してください。これにより、データベース エンジンに対する要求が、データベースに保存されたデータへの要求と同じディスクに送られるのを回避できます。

トレーニング時に RevoScaleR 分析関数を繰り返し実行する場合も、ディスク IO がパフォーマンスに大きな影響を与える可能性があります。 たとえば、`rxLogit`、`rxDTree`、`rxDForest` および `rxBTrees` では、複数の反復処理が使用されます。 データ ソースが SQL Server の場合、これらのアルゴリズムでは、データの取得用に最適化された一時ファイルが使用されます。 これらのファイルは、セッションの完了後に自動的にクリーンアップされます。 読み取り/書き込み操作に高パフォーマンスのディスクを使用すれば、これらのアルゴリズムの全体的な処理時間を大幅に改善することができます。

> [!NOTE]
> R Services の初期バージョンでは、Windows オペレーティング システムでの 8.3 ファイル名のサポートが必要でした。 この制限は、Service Pack 1 の後で解除されました。 しかし、fsutil.exe を使用すると、ドライブが 8.3 ファイル名をサポートしているかどうかを確認したり、サポートされていない場合にサポートを有効にすることができます。

### <a name="paging-file"></a>ページング ファイル

Windows オペレーティング システムでは、クラッシュ ダンプの管理や仮想メモリ ページの格納に、ページング ファイルが使用されます。 過度なページングに気付いた場合は、コンピューター上の物理メモリを増やすことを検討してください。 物理メモリを増やしてもページングがなくなるわけではありませんが、ページングの必要性が減ります。

ページ ファイルが格納されるディスクの速度も、パフォーマンスに影響する可能性があります。 ページ ファイルを SSD に格納したり、複数の SSD 間で複数のページ ファイルを使用すると、パフォーマンスを改善できる可能性があります。

ページ ファイルのサイズ調整について詳しくは、「[64 ビット版 Windows 用の適切なページ ファイルのサイズを確認する方法](https://support.microsoft.com/kb/2860880)」をご覧ください。

## <a name="optimizations-at-instance-or-database-level"></a>インスタンス レベルまたはデータベース レベルでの最適化

SQL Server インスタンスの最適化は、外部スクリプトを効率的に実行するために重要です。

> [!NOTE]
> 最適な設定は、データのサイズと種類、モデルのスコアリングやトレーニングに使用している列の数によって異なります。
> 
> 最後の記事では、特定の最適化の結果を確認できます。[パフォーマンス チューニング - ケース スタディの結果](../../advanced-analytics/r/performance-case-study-r-services.md)
> 
> サンプル スクリプトについては、別の [GitHub リポジトリ](https://github.com/Microsoft/SQL-Server-R-Services-Samples/tree/master/PerfTuning)を参照してください。

### <a name="table-compression"></a>テーブル圧縮

IO パフォーマンスは、圧縮や単票形式のデータ ストアを使用することで改善できる場合が多くあります。 一般に、データはテーブル内の複数の列で繰り返されることが多いため、列ストアを使用すると、データの圧縮時にこれらの繰り返しを利用することができます。

列ストアは、テーブルへの挿入が多い場合には効率的でない可能性がありますが、データが静的な場合や、変更の頻度が低い場合には、適切な選択肢と言えます。 列ストアが適切でない場合は、行メジャー テーブルでの圧縮を有効にすることで、IO を改善できる可能性があります。

詳しくは、次の各ドキュメントをご覧ください。

+ [データの圧縮](../../relational-databases/data-compression/data-compression.md)

+ [テーブルまたはインデックスの圧縮の有効化](../../relational-databases/data-compression/enable-compression-on-a-table-or-index.md)

+ [列ストア インデックス ガイド](../../relational-databases/indexes/columnstore-indexes-overview.md)

### <a name="memory-optimized-tables"></a>メモリ最適化テーブル

最近のコンピューターでは、メモリは問題ではなくなりました。 ハードウェアの仕様が改善し続けるにつれて、比較的簡単に RAM を低コストで入手できるようになりました。 ただし、同時に、データはかつてないほど迅速に生成されるようになり、データを短い待機時間で処理する必要があります。

メモリ最適化テーブルは、高性能のコンピューターで使用可能な大容量のメモリを利用してビッグ データの問題を解決するという点で、1 つの解決策を表しています。 メモリ最適化テーブルは、主にメモリ内に存在するので、データはメモリから読み込まれ、メモリに書き込まれます。 持続性を確保するために、テーブルの 2 番目のコピーはディスク上に保持され、データベースの復旧時にのみデータがディスクから読み取られます。

テーブルに対する読み取りと書き込みを頻繁に行う必要がある場合は、メモリ最適化テーブルを使用して、高いスケーラビリティと短い待機時間を実現できます。  再開照合シナリオでは、メモリ最適化テーブルを使用することで、データベースからすべての再開機能を読み取り、それらをメイン メモリに格納して新しいジョブのオープンと照合することができます。 これにより、ディスク IO が大幅に減少しました。

複数の同時実行バッチからデータベースに予測を書き戻すプロセスでメモリ最適化テーブルを使用することで、パフォーマンスがさらに向上しました。 SQL Server にメモリ最適化テーブルを使用すると、テーブルの読み取りと書き込みの待機時間が短くなります。

開発中のエクスペリエンスもシームレスになりました。 持続性のあるメモリ最適化テーブルは、データベースの作成時に同時に作成されました。 そのため、データの格納場所に関係なく開発で同じワークフローが使用されました。

### <a name="processor"></a>プロセッサ

SQL Server では、コンピューター上の利用可能なコアを使用して、タスクを並列で実行できます。利用可能なコアが多いほど、パフォーマンスは向上します。 コア数の増加は、IO バインドの操作にはメリットがない場合もありますが、CPU バインドのアルゴリズムでは、コア数の多い高速な CPU のメリットを得ることができます。

通常、サーバーは複数のユーザーによって同時に使用されるため、データベース管理者は、ピーク ワークロード計算をサポートするために必要とされる、理想的なコア数を決定する必要があります。

### <a name="resource-governance"></a>リソース管理

Resource Governor をサポートするエディションでは、リソース プールを使用して、特定のワークロードにいくつかの CPU が割り当てられるように指定できます。 また、特定のワークロードに割り当てられるメモリの量を管理することもできます。

SQL Server のリソース ガバナンスにより、SQL Server および R によって使用されるさまざまなリソースの監視と制御を一元化できます。たとえば、データベース エンジンに使用可能なメモリの半分を割り当てて、一時的に重いワークロードがあってもコア サービスを常に実行できるようにすることができます。

外部スクリプトによるメモリ消費の既定値は、SQL Server 自体で使用できる合計メモリの 20% に制限されています。 この制限は、データベース サーバーに依存するすべてのタスクが長時間実行されている R ジョブによって重大な影響を受けないようにするために、既定で適用されます。 ただし、これらの制限はデータベース管理者によって変更することもできます。 多くの場合、重大な機械学習ワークロードをサポートするには、20% の制限は適していません。

サポートされる構成オプションは、**MAX_CPU_PERCENT**、**MAX_MEMORY_PERCENT**、および **MAX_PROCESSES** です。 現在の設定を表示するには、次のステートメントを使用します。`SELECT * FROM sys.resource_governor_external_resource_pools`

-  サーバーが主に R Services 用に使用されている場合は、MAX_CPU_PERCENT を 40% や 60% に 増やすことでも効果が期待できます。

-  多くの R セッションで同時に同じサーバーを使用する必要がある場合は、3 つの設定をすべて増やす必要があります。

割り当てられたリソースの値を変更するには、T-SQL ステートメントを使用します。

+ 次のステートメントは、メモリ使用率を 40% に設定します。`ALTER EXTERNAL RESOURCE POOL [default] WITH (MAX_MEMORY_PERCENT = 40)`

+ 次のステートメントは、構成可能な 3 つの値をすべて設定しています。`ALTER EXTERNAL RESOURCE POOL [default] WITH (MAX_CPU_PERCENT = 40, MAX_MEMORY_PERCENT = 50, MAX_PROCESSES = 20)`

+ メモリ、CPU、または最大プロセスの設定を変更し、すぐに設定を適用する場合は、次のステートメントを実行します。`ALTER RESOURCE GOVERNOR RECONFIGURE`

## <a name="soft-numa-hardware-numa-and-cpu-affinity"></a>ソフト NUMA、ハードウェア NUMA、および CPU アフィニティ

SQL Server をコンピューティング コンテキストとして使用する場合、NUMA とプロセッサのアフィニティに関連する設定を調整することで、パフォーマンスを向上させることができる場合があります。 

_ハードウェア NUMA_ を使用するシステムには、それぞれがプロセッサの小さなセットとして機能する複数のシステム バスがあります。 各 CPU は他のグループに関連付けられているメモリには、一貫した方法でアクセスできます。 この CPU の各グループのことを NUMA ノードと呼びます。 ハードウェア NUMA を使用する場合は、NUMA ではなくインターリーブされたメモリを使用するように構成できます。 その場合、Windows および SQL Server では、この構成が NUMA として認識されません。 

SQL Server が使用できるメモリ ノードの数を調べるには、次のクエリを実行します。

```sql
SELECT DISTINCT memory_node_id
FROM sys.dm_os_memory_clerks
```

クエリが単一のメモリ ノード (ノード 0) を返す場合は、ハードウェア NUMA を備えていないか、またはハードウェアがインターリーブ (非 NUMA) として構成されています。 また、CPU が 4 つ以下の場合、または少なくとも 1 つのノードに CPU が 1 つしかない場合も、SQL Server はハードウェア NUMA を無視します。

コンピューターに複数のプロセッサが搭載されていても、ハードウェア NUMA が備えていない場合は、[ソフト NUMA](https://docs.microsoft.com/sql/database-engine/configure-windows/soft-numa-sql-server) を使用して、CPU をより小さなグループに分割することもできます。  SQL Server 2016 と SQL Server 2017 の両方で、SQL Server サービスを開始したときにソフト NUMA 機能が自動的に有効になります。

ソフト NUMA が有効になっていると、SQL Server によってノードが自動的に管理されます。ただし、特定のワークロードを最適化するために、_ソフト アフィニティ_を無効にして、ソフト NUMA ノードの CPU アフィニティを手動で構成することができます。 これにより、特にリソース ガバナンスをサポートする SQL Server のエディションを使用している場合に、どのワークロードがどのノードに割り当てられるかをより詳細に制御できるようになります。 CPU アフィニティを指定し、リソース プールを CPU のグループに合わせることで、待機時間を短縮し、関連するプロセスが同じ NUMA ノード内で実行されるようにすることができます。

R ワークロードをサポートするようにソフト NUMA と CPU アフィニティを構成する全体的なプロセスは次のとおりです。

1. ソフト NUMA を有効にする (使用可能な場合)
2. プロセッサのアフィニティを定義する
3. [Resource Governor](../r/resource-governance-for-r-services.md) を使用して外部プロセス用のリソース共有元を作成する
4. [ワークロード グループ](../../relational-databases/resource-governor/resource-governor-workload-group.md)を特定のアフィニティ グループに割り当てる

サンプル コードを含む詳細については、次のチュートリアルを参照してください。[SQL 最適化のヒントとテクニック (Ke Huang)](https://gallery.cortanaintelligence.com/Tutorial/SQL-Server-Optimization-Tips-and-Tricks-for-Analytics-Services)

**その他のリソース**

+ [SQL Server のソフト NUMA](https://docs.microsoft.com/sql/database-engine/configure-windows/soft-numa-sql-server)
    
    CPU へのソフト NUMA ノードのマッピング方法

## <a name="task-specific-optimizations"></a>タスク固有の最適化

このセクションでは、特定の機械学習ワークロードを最適化するために、これらのケース スタディとその他のテストで採用されている方法の概要を示します。 一般的なワークロードには、モデル トレーニング、特徴抽出、特徴エンジニアリング、およびスコアリングのためのさまざまなシナリオ (単一行、小さなバッチ、大きなバッチなど) が含まれます。

### <a name="feature-engineering"></a>機能エンジニアリング

R の 1 つの問題点は、通常、1 つの CPU で処理されることです。 これは、多くのタスク (特に特徴エンジニアリング) におけるパフォーマンスの大きなボトルネックです。 再開照合ソリューションでは、特徴エンジニアリング タスクだけでクロス積機能を 2500 作成し、それらを元の 100 の機能と組み合わせる必要がありました。 すべてが 1 つの CPU で実行された場合、このタスクにはかなりの時間がかかります。

特徴エンジニアリングのパフォーマンスを向上させるには、複数の方法があります。 R コードを最適化し、モデリング プロセス内に特徴抽出を維持するか、特徴エンジニアリング プロセスを SQL に移行することができます。

- R を使用します。関数を定義し、トレーニング中に [rxTransform](https://docs.microsoft.com/r-server/r-reference/revoscaler/rxtransform) に引数として渡します。 モデルで並列処理がサポートされている場合、特徴エンジニアリング タスクは複数の CPU を使用して処理できます。 このアプローチを使用して、データ サイエンス チームはスコアリング時間に関して 16% のパフォーマンス向上を実現しました。 ただし、この方法では、並列処理をサポートするモデルと、並列プランを使用して実行できるクエリが必要です。

- SQL コンピューティングのコンテキストで R を使用します。 分離されたリソースを個別のバッチの実行に使用できるマルチプロセッサ環境では、各バッチに使用される SQL クエリを分離してテーブルからデータを抽出し、同じワークロード グループにデータを制限することで、効率を高めることができます。 バッチを分離するために使用する方法には、パーティション分割、PowerShell を使用した個別のクエリの並列実行などが含まれます。

- アドホック並列実行:SQL Server コンピューティングのコンテキストでは、SQL データベース エンジンを使用して並列実行適用するオプションがより効率的であることがわかった場合に、可能であればそれを実行できます。

- T-SQL を別の特性付けプロセスで使用します。 一般に、SQL を使用して特徴データを事前に計算する方が高速です。

### <a name="prediction-scoring-in-parallel"></a>並列での予測 (スコアリング)

SQL Server の利点の 1 つは、大量の行を並列で処理できることです。 スコアリングほどのこの利点が活かせる場所はありません。 一般に、モデルはスコアリングのためにすべてのデータにアクセスする必要がないため、入力データをパーティション分割して、各ワークロード グループが 1 つのタスクを処理するようにすることができます。

また、入力データを 1 つのクエリとして送信し、その後で SQL Server でクエリを分析することもできます。 入力データに対して並列クエリ プランを作成できる場合は、ノードに割り当てられたデータが自動的にパーティション分割され、必要な結合と集計も並列で実行されます。

スコアリングに使用するストアド プロシージャを定義する方法の詳細については、[GitHub](https://github.com/Microsoft/SQL-Server-R-Services-Samples/tree/master/SQLOptimizationTips/SQLR) のサンプル プロジェクトを参照し、"step5_score_for_matching .sql" というファイルを探してください。 このサンプル スクリプトでは、クエリの開始時刻と終了時刻を追跡し、SQL コンソールに時間を出力するので、パフォーマンスを評価することもできます。

### <a name="concurrent-scoring-using-resource-groups"></a>リソース グループを使用した同時スコアリング

スコアリングの問題をスケールアップするには、数百万の項目を複数のバッチに分割するマップ削減アプローチを採用することをお勧めします。 その後で、複数のスコアリング ジョブが同時に実行されます。 このフレームワークでは、バッチは異なる CPU セットで処理され、結果が収集されてデータベースに書き戻されます。

これは、再開照合シナリオで使用されるアプローチです。ただし、この方法を実装するには、SQL Server のリソース ガバナンスが不可欠です。 外部スクリプト ジョブ用のワークロード グループを設定することにより、R スコアリング ジョブを異なるプロセッサ グループにルーティングして、より高速なスループットを実現することができます。

リソース ガバナンスは、サーバー上で使用可能なリソース (CPU およびメモリ) を分割して割り当て、ワークロードの競合を最小限に抑えるためにも役立ちます。 異なる種類の R ジョブを区別するように分類子関数を設定できます。たとえば、アプリケーションから呼び出されたスコアリングを常に優先し、再トレーニング ジョブの優先度が低いと判断できる場合などがあります。 このリソースの分離によって、実行時間が短縮され、より正確に予測できるパフォーマンスが提供される可能性があります。

### <a name="concurrent-scoring-using-powershell"></a>PowerShell を使用した同時スコアリング

データを自分でパーティション分割する場合は、PowerShell スクリプトを使用して、複数の同時スコアリング タスクを実行できます。 これを行うには、Invoke-SqlCmd コマンドレットを使用して、スコアリング タスクを並行して開始します。

再開照合シナリオでは、同時実行は次のように設計されています。

- 20 基のプロセッサが、それぞれ 5 つの CPU から成る 4 つのグループに分けられています。 CPU の各グループは、同じ NUMA ノードに配置されます。

- 同時に実行するバッチの最大数が 8 に設定されます。

- 各ワークロード グループは、2 つのスコアリング タスクを処理する必要があります。 1 つのタスクのデータの読み取りが終了し、スコアリングが開始されるとすぐに、他のタスクがデータベースからのデータの読み取りを開始することができます。

このシナリオの PowerShell スクリプトを表示するには、[Github プロジェクト](https://github.com/Microsoft/SQL-Server-R-Services-Samples/tree/master/SQLOptimizationTips)の experiment.ps1 ファイルを開きます。

### <a name="storing-models-for-prediction"></a>予測のためのモデルの格納

トレーニングと評価を完了して最善のモデルを選択したら、そのモデルをデータベースに格納して予測で使用できるようにすることをお勧めします。 SQL Server Machine Learning では、R とデータベース間を移動するときに、特別なシリアル化アルゴリズムを使用してモデルを格納および読み込むため、事前に計算されたモデルをデータベースから予測用に読み込むと効率が向上します。

> [!TIP]
> SQL Server 2017 では、サーバーに R がインストールされていない場合でも、PREDICT 関数を使用してスコアリングを実行できます。 RevoScaleR パッケージからは、制限されたモデルの種類がサポートされています。

ただし、使用するアルゴリズムによっては、一部のモデルが非常に大きくなる場合があります (特に、大規模なデータセットに対してトレーニングを行う場合)。 たとえば、 **lm** や **glm** などのアルゴリズムでは、ルールと共に多数の概要データが生成されます。 Varbinary 列に格納できるモデルのサイズには制限があるため、実稼働環境でモデルをデータベースに格納する前に、モデルから不要な成果物を除外することをお勧めします。

## <a name="articles-in-this-series"></a>このシリーズの記事

[R のパフォーマンス チューニング - 概要](../r/sql-server-r-services-performance-tuning.md)

[R のパフォーマンス チューニング - SQL Server の構成](../r/sql-server-configuration-r-services.md)

[R のパフォーマンス チューニング - R コードおよびデータの最適化](../r/r-and-data-optimization-r-services.md)

[パフォーマンス チューニング - ケース スタディの結果](../r/performance-case-study-r-services.md)
